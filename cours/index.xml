<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Cours on  </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://prof.bpesquet.fr/cours/index.xml/</link>
    
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Composants matériels de l&#39;ordinateur</title>
      <link>http://prof.bpesquet.fr/cours/composants-materiels-ordinateur</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/composants-materiels-ordinateur</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est de vous présenter ce qu&amp;rsquo;est un ordinateur
ainsi que les bases de son fonctionnement.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/calvin_computer.jpg&#34; class=&#34;content centered&#34; alt=&#34;calvin_computer.jpg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Généralités sur les ordinateurs&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Qu&amp;rsquo;est-ce qu&amp;rsquo;un ordinateur ?&lt;/h2&gt;

&lt;p&gt;Le dictionnaire Larousse définit l&amp;rsquo;ordinateur de la manière suivante :&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Un ordinateur est une machine automatique de traitement de l&amp;rsquo;information, obéissant à des programmes formés par des suites d&amp;rsquo;opérations arithmétiques et logiques.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;L&amp;rsquo;ordinateur n&amp;rsquo;est donc rien de plus qu&amp;rsquo;une machine qui effectue des opérations logiques et arithmétiques à la chaîne.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Le terme &amp;ldquo;ordinateur&amp;rdquo; est générique. Il peut désigner aussi bien un ordinateur de bureau classique qu&amp;rsquo;un serveur de calcul ou encore un terminal mobile.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Trouvez des exemples d&amp;rsquo;ordinateurs.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Tout ordinateur, même très performant, n&amp;rsquo;est qu&amp;rsquo;une &lt;strong&gt;machine&lt;/strong&gt; capable d&amp;rsquo;exécuter automatiquement une série d&amp;rsquo;opérations qu&amp;rsquo;on lui a demandées. Il ne dispose par lui-même d&amp;rsquo;aucune capacité d&amp;rsquo;apprentissage, de jugement, d&amp;rsquo;improvisation, bref d&amp;rsquo;aucune &amp;ldquo;intelligence&amp;rdquo;. Il se contente de &lt;strong&gt;faire ce qu&amp;rsquo;on lui dit de faire&lt;/strong&gt;. L&amp;rsquo;intérêt des ordinateurs est de savoir manipuler très rapidement et sans erreur d&amp;rsquo;énormes quantités d&amp;rsquo;informations.&lt;/p&gt;

&lt;p&gt;Tout ordinateur est composé de plusieurs types d&amp;rsquo;éléments en interaction :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Des éléments matériels : processeur, mémoire, etc.&lt;/li&gt;
&lt;li&gt;Un système d&amp;rsquo;exploitation qui permet d&amp;rsquo;exploiter les éléments matériels.&lt;/li&gt;
&lt;li&gt;Des applications, logiciels utilisant le système d&amp;rsquo;exploitation pour offrir des fonctionnalités à l&amp;rsquo;utilisateur de l&amp;rsquo;ordinateur.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Un peu d&amp;rsquo;histoire&lt;/h2&gt;

&lt;p&gt;Même si l&amp;rsquo;histoire ancienne a vu l&amp;rsquo;apparition de diverses machines à compter et à calculer (boulier, Pascaline, etc), l&amp;rsquo;informatique est une science très récente dont voici les principales étapes.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;1945-1956 : les ordinateurs mécaniques&lt;/h3&gt;

&lt;p&gt;Les ordinateurs de cette génération sont surtout caractérisés par le fait que les instructions qu&amp;rsquo;ils comprennent correspondent spécialement à la tâche pour laquelle l&amp;rsquo;ordinateur a été conçu. Ils n&amp;rsquo;avaient aucune souplesse et des possibilités très limitées, concentrées sur une seule tâche précise. Ils utilisent également des tubes à vide (également appelées des lampes), ce qui explique leur taille, leur poids et leur consommation immense.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ENIAC&lt;/strong&gt; (&lt;em&gt;Electronic Numerical Integrator And Computer&lt;/em&gt;) est un très bon exemple d&amp;rsquo;ordinateur de première génération. Il n&amp;rsquo;était qu&amp;rsquo;une gigantesque et rapide calculatrice. On définissait un &amp;ldquo;programme&amp;rdquo; en branchant tout un ensemble de câbles.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/eniac.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;eniac.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;1956-1963 : les ordinateurs à transistors&lt;/h3&gt;

&lt;p&gt;L&amp;rsquo;invention du &lt;strong&gt;transistor&lt;/strong&gt; en 1947 bouleverse le développement des ordinateurs. Remplaçant les tubes à vide un peu partout (télévisions, radios), il a été utilisé dans un ordinateur pour la première fois en 1956, par Bell.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/premier_transistor.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;premier_transistor.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cette même année, IBM (&lt;em&gt;International Business Machines&lt;/em&gt;, société fondée en 1940) met au point le premier disque dur, constitué d&amp;rsquo;une pile de 50 plateaux de 61 cm de diamètre. Il peut stocker 5 Mo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/premier_disque_dur.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;premier_disque_dur.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;À partir de 1960, les ordinateurs à transistors commençaient à incorporer efficacement des périphériques que l&amp;rsquo;on considère maintenant comme courants: disques magnétiques, enregistreurs à bandes magnétiques, imprimantes, mémoire. Ils avaient également des systèmes d&amp;rsquo;exploitation rudimentaires et on pouvait stocker des programmes en mémoire.&lt;/p&gt;

&lt;p&gt;Ces programmes stockés en mémoire et la possibilité d&amp;rsquo;aller modifier ces programmes pour leur faire réaliser d&amp;rsquo;autres fonctions ont donné à l&amp;rsquo;ordinateur la flexibilité qui leur manquait. Ils permettaient d&amp;rsquo;utiliser des mots, des phrases et des formules mathématiques plus proches du langage humain.  L&amp;rsquo;industrie du logiciel a commencé à se développer.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;1964-1971 : les ordinateurs à circuits intégrés&lt;/h3&gt;

&lt;p&gt;Le transistor était un bon pas en avant par rapport aux tubes à vide, mais il générait beaucoup de chaleur et endommageait souvent les parties internes sensibles de l&amp;rsquo;ordinateur. L&amp;rsquo;apparition du circuit intégré en 1964 a révolutionné le monde de l&amp;rsquo;informatique. Le premier circuit intégré réunissait trois composants électroniques sur un même (petit) support. Son arrivée a permis de diminuer encore la taille des ordinateurs, ainsi que leur consommation et leur émission de chaleur.&lt;/p&gt;

&lt;p&gt;En 1967, IBM construit le premier lecteur de disquettes, qui devient un moyen populaire de stocker des données temporairement beaucoup plus pratique que les bandes magnétiques.&lt;/p&gt;

&lt;p&gt;Un autre développement propre à la troisième génération: l&amp;rsquo;amélioration et l&amp;rsquo;utilisation courante des systèmes d&amp;rsquo;exploitation, un programme central qui gérait la mémoire de l&amp;rsquo;ordinateur et permettait de faire
tourner plusieurs programmes sur un même ordinateur – les ancêtres de Windows !&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;Depuis 1971 : la micro-informatique&lt;/h3&gt;

&lt;p&gt;Avec l&amp;rsquo;apparition des circuits intégrés, la tendance est allée vers la miniaturisation. Depuis les années 80, on est capable de mettre plusieurs centaines de milliers, voire des millions de composants sur un support de la même surface. Tout ceci permis de réduire considérablement la taille et le coût des ordinateurs, tout en améliorant leur puissance et leur fiabilité. Le microprocesseur est né.&lt;/p&gt;

&lt;p&gt;Sa généralisation pousse des compagnies comme Tandy, Commodore et Apple à commercialiser les premiers ordinateurs personnels. En 1981, IBM lance son premier ordinateur personnel: l&amp;rsquo;IBM PC (il crée du même coup officiellement le terme). IBM donnant le droit à n&amp;rsquo;importe qui de copier son architecture : les clones de PC apparaissent partout, faisant baisser grandement les prix et rendant le PC le choix de millions d&amp;rsquo;utilisateurs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/ibm_pc.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;ibm_pc.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En 1984, le premier concurrent direct du PC d&amp;rsquo;IBM fait son entrée sur le marché: le MacIntosh d&amp;rsquo;Apple. Il est le premier à offrir un système d&amp;rsquo;exploitation graphique, laissant l&amp;rsquo;usager déplacer des icônes et des fenêtres avec une souris plutôt que de taper des commandes étranges avec un clavier.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/apple_macintosh.jpg&#34; class=&#34;content centered&#34; alt=&#34;apple_macintosh.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;C&amp;rsquo;est à cette époque qu&amp;rsquo;apparaissent les premiers ordinateurs portables, ou plutôt transportables tant leur poids (plus de 10 kg) et leur prix étaient dissuasifs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/premier_transportable.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;premier_transportable.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;De nos jours : des ordinateurs partout&lt;/h3&gt;

&lt;p&gt;L&amp;rsquo;époque actuelle se caractérise par une course à la puissance et à la miniaturisation des composants de l&amp;rsquo;ordinateur, liée à la concurrence que se livrent les fabricants de matériel.&lt;/p&gt;

&lt;p&gt;Cette évolution, ainsi que la généralisation de l&amp;rsquo;accès aux réseaux, a eu pour conséquence l&amp;rsquo;explosion de l&amp;rsquo;informatique mobile, avec des terminaux (smartphones, tablettes) disposant de la même puissance que les ordinateurs de bureau d&amp;rsquo;il y a quelques années&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/familles_ordinateurs.jpg&#34; class=&#34;content centered&#34; alt=&#34;familles_ordinateurs.jpg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Généralités sur les logiciels&lt;/h1&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Définition&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Faites une liste de logiciels que vous connaissez.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Chaque logiciel assure une tâche particulière pour répondre à un besoin précis.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Un logiciel est un programme qui permet à un système informatique d&amp;rsquo;assurer une tâche particulière (Wikipédia).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pour fonctionner, un logiciel exploite les ressources matérielles du système informatique qui l&amp;rsquo;héberge.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Les différents types de logiciels&lt;/h2&gt;

&lt;p&gt;On distingue deux grandes familles de logiciels :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Les logiciels système, appelés égalements &lt;strong&gt;systèmes d&amp;rsquo;exploitation&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Les logiciels d&amp;rsquo;application&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Trouvez des exemples de logiciels système.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;On peut catégoriser les logiciels d&amp;rsquo;application selon le type de tâche qu&amp;rsquo;ils réalisent.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Trouvez des catégories de logiciels d&amp;rsquo;application.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Les logiciels d&amp;rsquo;application utilisent les services offerts par le logiciel système qui les accueille.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/imbrication_logiciels.jpg&#34; class=&#34;content centered&#34; alt=&#34;imbrication_logiciels.jpg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;La création d&amp;rsquo;un logiciel&lt;/h2&gt;

&lt;h3 id=&#34;toc_12&#34;&gt;Le processus de création&lt;/h3&gt;

&lt;p&gt;L&amp;rsquo;origine d&amp;rsquo;un logiciel est un ensemble de fichiers appelé &lt;strong&gt;code source&lt;/strong&gt;. Ces fichiers sont écrits par un ou plusieurs programmeurs dans un langage particulier. En fonction du langage choisi, les fichiers source sont :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;transformés par un logiciel appelé &lt;strong&gt;compilateur&lt;/strong&gt; en un ou plusieurs fichiers exécutables (extension &lt;em&gt;.exe&lt;/em&gt; sous Windows).&lt;/li&gt;
&lt;li&gt;directement exécutés par un &lt;strong&gt;interpréteur&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De nos jours, de nombreux outils aident les programmeurs à créer des logiciels plus rapidement (génération d&amp;rsquo;une partie du code source, création de l&amp;rsquo;interface graphique&amp;hellip;).&lt;/p&gt;

&lt;h3 id=&#34;toc_13&#34;&gt;Les erreurs (bogues)&lt;/h3&gt;

&lt;p&gt;Plus le logiciel créé est complexe, plus il est difficile d&amp;rsquo;éviter les bogues (&lt;em&gt;bugs&lt;/em&gt;) dans sa conception.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un bogue est une erreur dans le code source du logiciel qui provoque un effet inattendu pendant son exécution.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;La distribution d&amp;rsquo;un logiciel&lt;/h2&gt;

&lt;p&gt;Le logiciel, création de l&amp;rsquo;esprit, est protégé par le droit. Son auteur est libre de choisir son mode de distribution à travers le choix d&amp;rsquo;une licence. On peut classer les logiciels en quatre catégories principales selon leur mode de distribution :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Les &lt;strong&gt;logiciels commerciaux&lt;/strong&gt; sont propriétaires et payants.&lt;/li&gt;
&lt;li&gt;Les &lt;strong&gt;partagiciels&lt;/strong&gt; (&lt;em&gt;sharewares&lt;/em&gt;) sont gratuits pour une période donnée, puis payants.&lt;/li&gt;
&lt;li&gt;Les &lt;strong&gt;graticiels&lt;/strong&gt; (&lt;em&gt;freewares&lt;/em&gt;) sont disponibles gratuitement, parfois en version bridée.&lt;/li&gt;
&lt;li&gt;Les &lt;strong&gt;logiciels libres&lt;/strong&gt; donnent à toute personne qui en possède une copie le droit de les utiliser, de les étudier, de les modifier et de les redistribuer. Ils sont fournis avec leur code source, et on rencontre parfois l&amp;rsquo;expression &amp;ldquo;open source&amp;rdquo; pour qualifier ces logiciels.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/copyleft.png&#34; class=&#34;content centered&#34; alt=&#34;copyleft.png&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Trouvez des exemples de logiciels pour chaque mode de distribution.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Il existe d&amp;rsquo;autres modes de distribution plus &amp;ldquo;exotiques&amp;rdquo; (carticiel, abandogiciel&amp;hellip;).&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;Architecture d&amp;rsquo;un ordinateur&lt;/h1&gt;

&lt;p&gt;Même si un ordinateur peut prendre des formes très différentes, du serveur au smartphone en passant par le PC du bureau, son architecture de base est identique d&amp;rsquo;un modèle à l&amp;rsquo;autre. Seule la taille (et les performances) de ses éléments changent.&lt;/p&gt;

&lt;p&gt;Un ordinateur se compose de plusieurs éléments matériels en interaction. L&amp;rsquo;image ci-dessous illustre l&amp;rsquo;architecture d&amp;rsquo;un PC de bureau (source : Wikipedia).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/eclate_ordinateur.png&#34; class=&#34;content centered&#34; alt=&#34;eclate_ordinateur.png&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;La carte mère&lt;/h1&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Ce paragraphe reprend un cours de mon collègue Pascal Chemin.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_17&#34;&gt;Le rôle de la carte mère&lt;/h2&gt;

&lt;p&gt;La carte mère est l’élément central d’un ordinateur.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/carte_mere.png&#34; class=&#34;content centered bordered&#34; alt=&#34;carte_mere.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Elle assure l&amp;rsquo;interconnexion entre tous les autres composants.&lt;/p&gt;

&lt;h2 id=&#34;toc_18&#34;&gt;Le format (ou facteur d’encombrement)&lt;/h2&gt;

&lt;p&gt;Le format d’une carte mère définit :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ses dimensions,&lt;/li&gt;
&lt;li&gt;les emplacements des points de fixation,&lt;/li&gt;
&lt;li&gt;le type d’alimentation à utiliser.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Les formats des cartes mère sont fortement liés aux formats des boîtiers.&lt;/p&gt;

&lt;p&gt;On trouve essentiellement trois types de formats pour une carte mère récente.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Format&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Format de boitier&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Dimensions&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ATX&lt;/td&gt;
&lt;td&gt;Ordinateur de bureau&lt;/td&gt;
&lt;td&gt;305x244 mm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Micro ATX&lt;/td&gt;
&lt;td&gt;Ordinateurs de bureau compacts&lt;/td&gt;
&lt;td&gt;244x244 mm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ITX&lt;/td&gt;
&lt;td&gt;Mini PC&lt;/td&gt;
&lt;td&gt;177x177mm&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/form_factors.png&#34; class=&#34;content centered&#34; alt=&#34;form_factors.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Le format ATX&lt;/strong&gt;. Ce sont les cartes mères de plus grande taille. Il faudra généralement un boîtier spacieux pour l’accueillir, muni d’une alimentation ATX. C’est le format de carte mère le plus répandu.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Le format micro ATX&lt;/strong&gt;. Format de carte compact. Il convient généralement aux boîtiers de type munis d’une alimentation ATX.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Le format ITX&lt;/strong&gt;. Format de carte mère ultracompact destiné exclusivement aux PC munis d’une alimentation ITX.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_19&#34;&gt;Le support processeur (socket)&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Le socket est le support qui permet au processeur d&amp;rsquo;être branché sur la carte mère.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/socket.png&#34; class=&#34;content centered&#34; alt=&#34;socket.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le socket est un réceptacle couvert de contacts. Le processeur va s’emboîter dans le réceptacle, les différents contacts vont s’établir par une pression sur un levier.&lt;/p&gt;

&lt;p&gt;Le type de support de votre carte mère peut être identifié grâce à des logiciels de diagnostic comme &lt;a href=&#34;http://www.aida64.com/&#34;&gt;AIDA64&lt;/a&gt; ou &lt;a href=&#34;http://www.sisoftware.net&#34;&gt;Sandra&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;La &lt;a href=&#34;http://fr.wikipedia.org/wiki/Socket_(processeur)&#34;&gt;page Wikipedia associée au socket&lt;/a&gt; donne toutes les informations nécessaires.&lt;/p&gt;

&lt;h2 id=&#34;toc_20&#34;&gt;Le support mémoire&lt;/h2&gt;

&lt;p&gt;Les cartes mères disposent de plusieurs supports mémoire permettant de connecter de la &lt;strong&gt;mémoire vive&lt;/strong&gt; (RAM, &lt;em&gt;Random Access Memory&lt;/em&gt;) sous la forme de barrettes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/carte_mere_ram.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;carte_mere_ram.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Avant un achat, il est important de vérifier la compatibilité des barrettes avec la carte mère.&lt;/p&gt;

&lt;h2 id=&#34;toc_21&#34;&gt;Les &lt;em&gt;chipsets&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Les chipsets sont des &lt;strong&gt;composants&lt;/strong&gt; de la carte mère chargés de gérer les flux entre les différents composants de l’ordinateur.&lt;/p&gt;

&lt;p&gt;On trouve deux composants essentiels à la carte mère qui se partagent les communications en fonction de la vitesse de communication et du nombre d’informations échangés :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Le &lt;em&gt;northbridge&lt;/em&gt; (&amp;ldquo;pont nord&amp;rdquo;) gère les échanges de données entre les composants ayant besoin d’échanger un très grand nombre d’informations dans un laps de temps très faible :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Processeur,&lt;/li&gt;
&lt;li&gt;Mémoire vive&lt;/li&gt;
&lt;li&gt;Carte graphique&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Le &lt;em&gt;southbridge&lt;/em&gt; (&amp;ldquo;pont sud&amp;rdquo;) gére les échanges de données entre les composants ayant besoin d’échanger un nombre plus faible d’informations : les périphériques d’entrée et sortie.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/schema_bus_CM.png&#34; class=&#34;content centered&#34; alt=&#34;schema_bus_CM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les chipsets déterminent quels composants sont supportés :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;le processeur,&lt;/li&gt;
&lt;li&gt;les mémoires,&lt;/li&gt;
&lt;li&gt;les types de ports gérés (USB, PCI Express, AGP, SATA, etc.).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Trouvez les noms des principaux constructeurs de &lt;em&gt;chipsets&lt;/em&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Evolutions récentes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Le northbridge traditionnel est destiné à disparaître.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Le contrôleur mémoire, qui assure la communication entre le processeur et la RAM, a été intégré dans le cœur des processeurs AMD64 ou Intel Core i7.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_22&#34;&gt;Les ports internes&lt;/h2&gt;

&lt;p&gt;Parmi les ports interne d&amp;rsquo;une carte mère, les &lt;strong&gt;ports d’extension&lt;/strong&gt; permettent de connecter des cartes supplémentaires dans votre PC. Les cartes les plus courantes sont :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;les cartes graphiques,&lt;/li&gt;
&lt;li&gt;les cartes son,&lt;/li&gt;
&lt;li&gt;les cartes réseau.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_23&#34;&gt;Les port PCI et PCI Express&lt;/h3&gt;

&lt;p&gt;Le port PCI se trouve encore sur les cartes mères, mais ce type de port est en perte de vitesse. Il propose des débits trop faibles pour supporter certaines cartes. Il est remplacé par les ports PCI Express. Le débit de ces ports est beaucoup plus important.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/ports_pciexpress.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;ports_pciexpress.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ces ports sont différents physiquement comme le montre ce schéma. Plus l’indice multiplicateur est élevé plus le débit proposé est important.&lt;/p&gt;

&lt;h3 id=&#34;toc_24&#34;&gt;Le port ATA&lt;/h3&gt;

&lt;p&gt;Il est destiné à la connexion de disques durs ou de lecteurs optiques. Il s&amp;rsquo;agit d&amp;rsquo;une ancienne norme en voie de disparition. La connexion du composant se fait grâce à une nappe plate de 40 à 80 fils munie de 3 connecteurs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/port_pata.png&#34; class=&#34;content centered bordered&#34; alt=&#34;port_pata.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les connecteurs ATA sur les cartes mères sont encore largement répandus, mais leur nombre a diminué : la plupart des cartes mères n’offrent plus qu’un seul port ATA.&lt;/p&gt;

&lt;h3 id=&#34;toc_25&#34;&gt;Les ports SATA (SATA2, SATA3)&lt;/h3&gt;

&lt;p&gt;Cette norme vient remplacer l’ancien standard ATA. Cette technologie propose des débits plus importants que la norme ATA particulièrement pour les normes SATA2 et SATA3 qui offrent un débit théorique plusieurs fois supérieur au SATA1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/port_sata.png&#34; class=&#34;content centered bordered&#34; alt=&#34;port_sata.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La norme SATA présente d’autres avantages :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Les câbles Serial ATA peuvent mesurer jusqu’à 1 mètre de long (contre 45 cm pour les nappes ATA).&lt;/li&gt;
&lt;li&gt;Le faible nombre de fils dans la gaine donne plus de souplesse au câble et contribue à une meilleure circulation de l’air dans le boîtier.&lt;/li&gt;
&lt;li&gt;Les périphériques SATA sont seuls sur chaque câble et il n’est plus nécessaire de définir des périphériques ATA maîtres et esclaves.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_26&#34;&gt;Les ports externes&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/ports_externes_CM.png&#34; class=&#34;content centered&#34; alt=&#34;ports_externes_CM.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_27&#34;&gt;Le port USB&lt;/h3&gt;

&lt;p&gt;C’est un port extrêmement connu pour son caractère universel. On peut connecter une multitude de périphériques sur ce type de port (imprimante, scanner, disque dur, clavier, webcam, clé&amp;hellip;).&lt;/p&gt;

&lt;p&gt;Il existe trois types de port USB, les types USB1, USB2 et USB3. Le type USB2 est deux fois plus rapide que le type USB1 en termes de débit. Le type USB3 est encore plus rapide que l’USB2.&lt;/p&gt;

&lt;h3 id=&#34;toc_28&#34;&gt;Le port eSata&lt;/h3&gt;

&lt;p&gt;Ce type de port est apparu récemment sur les cartes mères. C&amp;rsquo;est une version externe des ports SATA.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/port_esata.png&#34; class=&#34;content centered bordered&#34; alt=&#34;port_esata.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le débit proposé par cette technologie est très rapide, les taux de transfert sont identiques à la version interne. Ce type de port est donc particulièrement adapté pour des disques durs externes.&lt;/p&gt;

&lt;h3 id=&#34;toc_29&#34;&gt;Les ports PS2, parallèle, série&lt;/h3&gt;

&lt;p&gt;L’ensemble de ces ports a quasiment disparu des cartes mères actuelles.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Le port PS2 est destiné à connecter un clavier ou une souris.&lt;/li&gt;
&lt;li&gt;Les ports parallèles autorisent l’utilisation d’une imprimante.&lt;/li&gt;
&lt;li&gt;Les ports série (ports RS-232) sont fréquemment utilisées dans l&amp;rsquo;industrie pour connecter différents appareils électroniques (automate, appareil de mesure, etc.) et des actifs réseau (routeurs).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Les ports série sont souvent désignés par les noms COM1, COM2, etc. Cela leur a valu le surnom de « ports COM », encore utilisé de nos jours.&lt;/p&gt;

&lt;h2 id=&#34;toc_30&#34;&gt;Le réseau&lt;/h2&gt;

&lt;h3 id=&#34;toc_31&#34;&gt;Réseau filaire&lt;/h3&gt;

&lt;p&gt;La quasi-totalité des cartes mères possède une voire plusieurs prises réseaux (RJ45). Ces connecteurs supportent différents taux de transfert, les plus courants sont 100 Mbit/s ou 1 Gbit/s (1000 Mbit/s).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/port_rj45.png&#34; class=&#34;content centered bordered&#34; alt=&#34;port_rj45.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_32&#34;&gt;Réseau sans fil&lt;/h3&gt;

&lt;p&gt;Certaines cartes mères récentes intègrent les fonctionnalités des cartes Wi-Fi. Elles prennent en charge la plupart des normes actuelles à savoir 802.11b et 802.11g. Ces cartes mères sont généralement pourvues d’un connecteur pour une antenne Wi-Fi.&lt;/p&gt;

&lt;h2 id=&#34;toc_33&#34;&gt;Le multimédia&lt;/h2&gt;

&lt;h3 id=&#34;toc_34&#34;&gt;Audio&lt;/h3&gt;

&lt;p&gt;Les cartes mères intègrent depuis de nombreuses années des cartes son. Autrefois de piètre qualité et limitées à la stéréo, les cartes son intégrées ont beaucoup progressé en qualité et délivrent désormais un son multicanal (5.1, 7.1). Néanmoins, elles n’arrivent pas au degré de qualité et de performance que peut offrir une carte son séparée connectée sur un port PCI ou PCI Express.&lt;/p&gt;

&lt;h3 id=&#34;toc_35&#34;&gt;Vidéo&lt;/h3&gt;

&lt;p&gt;Les cartes mères récentes intègrent souvent un circuit graphique intégré qui joue le rôle de carte graphique. Les performances de ces circuits sont souvent modestes et peu en adéquation avec une utilisation ludique du PC (jeux !).&lt;/p&gt;

&lt;p&gt;Une carte mère récente propose maintenant :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un connecteur VGA (signal analogique) et&lt;/li&gt;
&lt;li&gt;un connecteur DVI (Digital Visual Interface, signal numérique)) et/ou&lt;/li&gt;
&lt;li&gt;un connecteur HDMI (High Definition Multimedia Interface, signal numérique qui délivre à la fois l’image et le son).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_36&#34;&gt;Le BIOS&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Le BIOS est le programme chargé d’initialiser l’ordinateur avant le démarrage du système d’exploitation.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Les informations de base concernant la configuration du matériel d’un ordinateur sont stockées dans une puce appelé CMOS (Complementary Metal Oxide Semiconductor) qui est gardée sous alimentation constante par la batterie de sauvegarde (pile ou accumulateur) de l&amp;rsquo;ordinateur. L’utilisateur peut paramétrer le BIOS selon ses besoins.&lt;/p&gt;

&lt;p&gt;Les BIOS varient d’un constructeur à l’autre, par le nombre d’options et l’ergonomie. Des mises à jour du BIOS sont régulièrement disponibles sur le site du constructeur. Ceci pour corriger des problèmes de conception du programme ou proposer des fonctionnalités ou des technologies supplémentaires&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/bios.png&#34; class=&#34;content centered bordered&#34; alt=&#34;bios.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pour accéder au paramétrage du BIOS, il faut souvent au démarrage du PC utiliser une touche ou une combinaison de touches : &lt;code&gt;DEL&lt;/code&gt;, &lt;code&gt;F2&lt;/code&gt;, &lt;code&gt;F10&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;toc_37&#34;&gt;La notion de bus&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un bus informatique est un système de communication partagé entre plusieurs composants d&amp;rsquo;un système numérique. Il s&amp;rsquo;agit d&amp;rsquo;un ensemble de liaisons physiques (câbles, pistes de circuits imprimés, etc.) pouvant être exploitées en commun par plusieurs éléments matériels afin de communiquer.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Au sein d&amp;rsquo;une carte mère coexistent différents &lt;strong&gt;bus&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Bus mémoire&lt;/strong&gt; (ou &lt;strong&gt;bus processeur&lt;/strong&gt; ou &lt;em&gt;front-side-bus&lt;/em&gt;, noté &lt;strong&gt;FSB&lt;/strong&gt;) : permet au processeur de communiquer avec la mémoire vive du système.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Bus de données interne&lt;/strong&gt; : véhicule les instructions en provenance ou
à destination du processeur.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;DMA&lt;/strong&gt; (&lt;em&gt;Direct Memory Access&lt;/em&gt;) : bus qui permet l&amp;rsquo;accès direct à la mémoire vive sans passer par le
processeur (permet ainsi une accélération importante des performances).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le rôle d&amp;rsquo;un bus est le transport de données. Sa vitesse, appelée débit binaire, est la quantité de bits pouvant y transiter par unité de temps. Il se calculera en bits par seconde, ou en octets par seconde.&lt;/p&gt;

&lt;p&gt;La vitesse d&amp;rsquo;un bus dépend du nombre de lignes physiques sur lesquelles les données sont envoyées de manière simultanée. Une nappe de 32 fils permet ainsi de transmettre 32 bits en parallèle. On parle ainsi de
largeur pour désigner le nombre de bits qu&amp;rsquo;un bus peut transmettre simultanément.&lt;/p&gt;

&lt;p&gt;D&amp;rsquo;autre part, la vitesse du bus est également définie par sa fréquence (exprimée en Hertz), c&amp;rsquo;est-à-dire le nombre de paquets de données envoyés ou reçus par seconde. On parle de cycle pour désigner chaque envoi ou réception de données.&lt;/p&gt;

&lt;p&gt;Lorsque les bits sont convoyés les uns à la suite des autres sur une seule et même ligne, on parle alors de *&lt;em&gt;bus série* (*serial bus&lt;/em&gt;). Exemples : USB, SATA.&lt;/p&gt;

&lt;p&gt;Lorsque les bits sont véhiculés simultanément sur plusieurs lignes parallèles, on parle alors, ô surprise, de &lt;strong&gt;bus parallèle&lt;/strong&gt; (&lt;em&gt;parallel bus&lt;/em&gt;). Exemple : PATA.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/bus_serie_parallele.png&#34; class=&#34;content centered&#34; alt=&#34;bus_serie_parallele.png&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_38&#34;&gt;Le processeur&lt;/h1&gt;

&lt;h2 id=&#34;toc_39&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Le processeur, appelé en anglais CPU (&lt;em&gt;Central Processing Unit&lt;/em&gt;) est à la
fois le cerveau et le coeur de l&amp;rsquo;ordinateur :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Le cerveau, car son rôle est d&amp;rsquo;exécuter les instructions qui composent les programmes informatiques.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Le coeur, parce qu&amp;rsquo;il exécute ces instructions au rythme (très rapide) de son horloge interne, appelé sa fréquence.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il est le plus souvent construit en un seul composant électronique (ou puce électronique) appelé &lt;strong&gt;circuit intégré&lt;/strong&gt;. On l&amp;rsquo;appelle alors microprocesseur. Sur ce circuit sont assemblés un nombre énorme (actuellement plus d&amp;rsquo;un milliard) de composants électroniques semi-conducteurs appelés des transistors.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/processeur.jpg&#34; class=&#34;content centered&#34; alt=&#34;processeur.jpg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_40&#34;&gt;Histoire des processeurs&lt;/h2&gt;

&lt;p&gt;Les premiers processeurs sont apparus en même temps que les premiers ordinateurs, dans les années 1940. A l&amp;rsquo;époque, ils étaient prévus spécifiquement pour une machine donnée. Dans les années 1970 sont apparus les premiers processeurs capables de fonctionner sur plusieurs machines (la société Intel a fabriqué son premier processeur en 1971). Cette standardisation s&amp;rsquo;est accélérée avec l&amp;rsquo;apparition des circuits intégrés, qui ont permis la miniaturisation des processeurs.&lt;/p&gt;

&lt;p&gt;Depuis, les progrès scientifiques et industriels ont conduit à une augmentation constante de la densité de transistors sur un même circuit intégré. Le co-fondateur d&amp;rsquo;Intel, Gordon Moore, a formulé en 1965 une prédiction célèbre appelée depuis &lt;strong&gt;loi de Moore&lt;/strong&gt; : &amp;ldquo;le nombre de transistors sur un microprocesseur doublera approximativement tous les deux ans&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A l&amp;rsquo;époque, le circuit le plus performant comportant 64 transistors. De nos jours, un processeur Core i7 comporte plus d&amp;rsquo;un milliard de transistors !&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/processeur_nombre_transistors.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;processeur_nombre_transistors.jpg&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Trouvez les noms des principaux fabricants de processeurs.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_41&#34;&gt;Types de processeur&lt;/h2&gt;

&lt;h3 id=&#34;toc_42&#34;&gt;Pour ordinateur de bureau&lt;/h3&gt;

&lt;p&gt;Les ordinateurs de bureau permettent généralement d’exécuter des applications telles que des logiciels de traitement de texte, des feuilles de calcul et des applications réseau de type messagerie et navigation Web.&lt;/p&gt;

&lt;p&gt;Exemples de processeurs de bureau récents pour Intel et AMD : Celeron, Pentium, Core i3, i5, i7, Phenom, Athlon, Sempron.&lt;/p&gt;

&lt;h3 id=&#34;toc_43&#34;&gt;Pour ordinateur portable&lt;/h3&gt;

&lt;p&gt;Les processeurs pour ordinateur portable sont conçus pour avoir une consommation d’énergie réduite. L’autonomie d’un ordinateur portable lorsqu’il fonctionne sur batterie est une caractéristique importante. Pour obtenir une consommation moindre, les processeurs d’ordinateurs portables sont alimentés par une tension plus faible et fonctionnent généralement à des fréquences moins élevées que les ordinateurs de bureau.&lt;/p&gt;

&lt;p&gt;AMD et Intel déclinent pour les ordinateurs portables des versions de leurs processeurs pour ordinateur de bureau.&lt;/p&gt;

&lt;h3 id=&#34;toc_44&#34;&gt;Pour station de travail&lt;/h3&gt;

&lt;p&gt;Les stations de travail sont de puissants ordinateurs d’entreprise. Elles sont conçues pour exécuter des applications de pointe, spécialisées, comme les programmes d’ingénierie, par exemple la CAO (Conception Assistée par Ordinateur). Les stations de travail sont utilisées dans la conception d’images 3D, l’animation vidéo. Elles peuvent également servir de stations de gestion d’équipements médicaux ou de télécommunications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/station-travail.png&#34; class=&#34;content centered&#34; alt=&#34;station-travail.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les stations de travail possèdent plusieurs processeurs qui doivent gérer une importante quantité de mémoire vive et plusieurs disques durs haute capacité, très rapides.&lt;/p&gt;

&lt;p&gt;Exemples pour Intel et AMD : Xeon, Itanium, Opteron + séries E et C.&lt;/p&gt;

&lt;h3 id=&#34;toc_45&#34;&gt;Pour serveur&lt;/h3&gt;

&lt;p&gt;Le matériel serveur est optimisé afin de fournir des réponses rapides à différentes requêtes réseau. Les serveurs peuvent être sollicités par plusieurs dizaines à plusieurs milliers de logiciels clients à la fois.&lt;/p&gt;

&lt;p&gt;Il existe plusieurs formats de serveurs :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Serveurs tour : adaptés aux plus petites entreprises.&lt;/li&gt;
&lt;li&gt;Serveur rack : empilables dans des baies dédiées.&lt;/li&gt;
&lt;li&gt;Serveurs lame (&lt;em&gt;blade&lt;/em&gt;) : concentrent le maximum de puissance et d’évolutivité&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/format-serveurs.jpg&#34; class=&#34;content centered&#34; alt=&#34;format-serveurs.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les serveurs sont dotés de plusieurs processeurs qui accèdent à une quantité importante de mémoire vive.&lt;/p&gt;

&lt;p&gt;Exemples pour Intel et AMD : Xeon, Opteron série 4000 et 6000.&lt;/p&gt;

&lt;h2 id=&#34;toc_46&#34;&gt;Caractéristiques des processeurs&lt;/h2&gt;

&lt;h3 id=&#34;toc_47&#34;&gt;La fréquence&lt;/h3&gt;

&lt;p&gt;La fréquence ou vitesse d&amp;rsquo;horloge est un concept relativement simple à
comprendre. Elle se mesure actuellement en GigaHertz (GHz) et correspond
au nombre d’opérations élémentaires que le processeur est capable
d’effectuer en une seconde.&lt;/p&gt;

&lt;p&gt;Ainsi, un processeur fonctionnant à une fréquence de 3 Ghz peut traiter 3 milliards d&amp;rsquo;opérations élémentaires à la seconde.&lt;/p&gt;

&lt;h3 id=&#34;toc_48&#34;&gt;Les registres&lt;/h3&gt;

&lt;p&gt;Lorsque le processeur exécute des instructions, les données sont temporairement stockées dans de petites mémoires rapides de 8, 16, 32 ou 64 bits que l&amp;rsquo;on appelle registres.&lt;/p&gt;

&lt;p&gt;Un registre est un emplacement de mémoire interne à un processeur. Les registres se situent au sommet de la hiérarchie mémoire : il s&amp;rsquo;agit de la mémoire au meilleur temps d&amp;rsquo;accès, mais dont le coût de fabrication est le plus élevé.&lt;/p&gt;

&lt;p&gt;La largeur d’un processeur est un concept plus complexe, car trois caractéristiques du processeur s’expriment sous la forme d’une largeur :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;le bus d’entrées/sorties de données;&lt;/li&gt;
&lt;li&gt;le bus d’adresses;&lt;/li&gt;
&lt;li&gt;les registres internes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/processeur-largeur-registres.png&#34; class=&#34;content centered bordered&#34; alt=&#34;processeur-largeur-registres.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le bus de données du processeur se nomme également FSB (&lt;em&gt;Front-Side Bus&lt;/em&gt;), PSB (&lt;em&gt;Processor Side Bus&lt;/em&gt;) ou simplement bus processeur. Tous ces termes font référence au bus qui se trouve entre le processeur et le pont nord (North Bridge).&lt;/p&gt;

&lt;h3 id=&#34;toc_49&#34;&gt;Les instructions&lt;/h3&gt;

&lt;p&gt;Une instruction est l&amp;rsquo;opération élémentaire que le processeur peut
accomplir. Les instructions sont stockées dans la mémoire principale, en
vue d&amp;rsquo;être traitée par le processeur.&lt;/p&gt;

&lt;p&gt;Une instruction est composée de deux champs :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;le code opération, représentant l&amp;rsquo;action que le processeur doit accomplir ;&lt;/li&gt;
&lt;li&gt;le code opérande, définissant les paramètres de l&amp;rsquo;action. Le code opérande dépend de l&amp;rsquo;opération. Il peut s&amp;rsquo;agir d&amp;rsquo;une donnée ou bien d&amp;rsquo;une adresse mémoire.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Par exemple, l&amp;rsquo;opération A = B + C peut être traduite par la séquence suivante :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LOAD B R1&lt;/strong&gt; copie le contenu de l&amp;rsquo;adresse B dans le registre R1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ADD C R1&lt;/strong&gt; ajoute le contenu de l&amp;rsquo;adresse C dans ce registre&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STORE R1 A&lt;/strong&gt; stocke le contenu du registre à l&amp;rsquo;adresse A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/processeur-instructions.png&#34; class=&#34;content centered&#34; alt=&#34;processeur-instructions.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Chaque type de processeur gère un ensemble d’instructions appelé jeu d’instructions.&lt;/p&gt;

&lt;p&gt;Le jeu d&amp;rsquo;instructions est l&amp;rsquo;ensemble des opérations qu&amp;rsquo;un processeur peut exécuter,c&amp;rsquo;est-à-dire l&amp;rsquo;ensemble des circuits logiques qui y sont câblés. Ces circuits permettent d&amp;rsquo;effectuer des opérations élémentaires (addition, ET logique…) ou plus complexes (division, puissance…).&lt;/p&gt;

&lt;p&gt;De ce point de vue, il existe deux familles : les processeurs &lt;strong&gt;CISC&lt;/strong&gt; (&lt;em&gt;Complex Instruction Set Computer&lt;/em&gt;) et les processeurs &lt;strong&gt;RISC&lt;/strong&gt; (R pour &lt;em&gt;Reduced&lt;/em&gt;).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Les processeurs CISC embarquent de nombreuses instructions souvent très complexes mais prenant plusieurs cycles d&amp;rsquo;horloge.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;À l&amp;rsquo;opposé, les processeurs RISC ont un jeu d&amp;rsquo;instructions plus réduit mais chaque instruction n&amp;rsquo;utilise que quelques cycles d&amp;rsquo;horloge.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chaque nouvelle génération de processeur étend le jeu d’instructions standard pour permettre d&amp;rsquo;améliorer les performances dans des domaines spécifiques (3D, multimédia, etc). Voici quelques exemples : instructions MMX (1997), SSE (1999), SSE4 (2007).&lt;/p&gt;

&lt;h3 id=&#34;toc_50&#34;&gt;La mémoire cache&lt;/h3&gt;

&lt;p&gt;La mémoire cache est une mémoire très rapide permettant de réduire les délais d&amp;rsquo;attente des informations stockées en mémoire vive. En effet, la mémoire centrale (RAM) de l&amp;rsquo;ordinateur possède une vitesse bien moins importante que le processeur.&lt;/p&gt;

&lt;p&gt;Les processeurs modernes utilisent plusieurs mémoires caches s’intercalant entre le processeur et la mémoire centrale. On parle alors de niveau de cache : L1, L2 et L3 (L = Level). Le cache L1 est le plus rapide et le plus proche du microprocesseur, tandis que le cache L3 est le plus lent et plus proche de la mémoire vive.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/processeur-memoire-cache.png&#34; class=&#34;content centered&#34; alt=&#34;processeur-memoire-cache.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_51&#34;&gt;Le type de support (socket)&lt;/h3&gt;

&lt;p&gt;Chaque processeur est conçu pour être monté sur un support de carte mère précis, appelé &lt;strong&gt;socket&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;toc_52&#34;&gt;La finesse de gravure&lt;/h3&gt;

&lt;p&gt;La finesse de gravure d’un processeur correspond au procédé de fabrication utilisé pour fabriquer le cœur du processeur. Le procédé de fabrication consiste à &amp;ldquo;écrire&amp;rdquo; le plus finement possible les transistors qui sont la base de tout processeur pour assembler un plus grand nombre de transistors dans un espace plus réduit.&lt;/p&gt;

&lt;p&gt;La finesse de gravure est exprimée en nanomètres (nm, 10-9 m). Elle représente le diamètre (en nanomètres) du plus petit fil reliant deux composantes du microprocesseur. En comparaison, l&amp;rsquo;épaisseur d&amp;rsquo;un cheveu humain est de 100 microns = 100 000 nm.&lt;/p&gt;

&lt;p&gt;Plus la gravure est fine, plus le processeur va pouvoir :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fonctionner rapidement.&lt;/li&gt;
&lt;li&gt;dissiper moins de chaleur.&lt;/li&gt;
&lt;li&gt;consommer moins de courant électrique.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Trouvez la finesse de gravure des processeurs PC récents.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;toc_53&#34;&gt;La consommation électrique&lt;/h3&gt;

&lt;p&gt;La consommation d’un processeur est exprimée en Watts. Elle dépend de nombreux facteurs et en particulier de la vitesse d&amp;rsquo;horloge.&lt;/p&gt;

&lt;p&gt;Depuis quelques années, les préoccupations économiques et environnementales, ainsi que l&amp;rsquo;explosion du marché de la mobilité, ont conduit les fabricants de CPU à tenter de minimiser cette consommation, en particulier dans les versions mobiles de leurs processeurs.&lt;/p&gt;

&lt;h2 id=&#34;toc_54&#34;&gt;Technologies des processeurs&lt;/h2&gt;

&lt;h3 id=&#34;toc_55&#34;&gt;La technologie du pipeline&lt;/h3&gt;

&lt;p&gt;Afin d&amp;rsquo;optimiser le rendement, la technique du pipeline est apparue sur les processeurs 80386 d&amp;rsquo;Intel en 1985. Le pipeline permet de commencer à traiter l&amp;rsquo;instruction suivante avant d&amp;rsquo;avoir terminé la précédente via un mécanisme de &amp;ldquo;travail à la chaîne&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Cette technologie permet d&amp;rsquo;économiser de nombreux cycles d&amp;rsquo;horloge et donc d&amp;rsquo;augmenter les performances.&lt;/p&gt;

&lt;h3 id=&#34;toc_56&#34;&gt;La technologie Hyper-Threading&lt;/h3&gt;

&lt;p&gt;L&amp;rsquo;hyperthreading consiste à émuler au sein d&amp;rsquo;un seul processeur physique deux processeurs logiques, ce qui permet d’occuper le processeur de plus d&amp;rsquo;instructions et améliore son rendement. Ces deux processeurs logiques partagent les éléments du cœur de processeur, le cache et le bus système. Ainsi, deux processus peuvent être traités simultanément par le même processeur.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/processeur-hyperthreading.png&#34; class=&#34;content centered bordered&#34; alt=&#34;processeur-hyperthreading.png&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un &lt;em&gt;thread&lt;/em&gt; (ou fil) est une tâche élémentaire d&amp;rsquo;un programme en cours d&amp;rsquo;exécution. Les threads d&amp;rsquo;un programme peuvent s&amp;rsquo;exécuter en parallèle.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Sous Windows, on peut observer le nombre de threads grâce au
gestionnaire de tâches.&lt;/p&gt;

&lt;h3 id=&#34;toc_57&#34;&gt;La technologie multicœurs&lt;/h3&gt;

&lt;p&gt;Un processeur multicoeurs contient en réalité deux noyaux de processeur, ou plus, sur la même puce. De l’extérieur, il ressemble à un seul processeur. Un processeur multicoeurs possède tous les avantages d’un ensemble de processeurs physiques séparés, pour un coût moindre.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/processeur-multicoeur.png&#34; class=&#34;content centered bordered&#34; alt=&#34;processeur-multicoeur.png&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_58&#34;&gt;La mémoire&lt;/h1&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Ce paragraphe s&amp;rsquo;inspire d&amp;rsquo;un cours de mon collègue Pascal Chemin.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_59&#34;&gt;Généralités&lt;/h2&gt;

&lt;p&gt;Dans un ordinateur, la mémoire sert à stocker les informations manipulées par le processeur. Il existe plusieurs catégories de mémoire, adaptées à des usages différents. On peut les classifier en fonction de l’éloignement par rapport au processeur.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/memoire-triangle-vitesse.png&#34; class=&#34;content centered bordered&#34; alt=&#34;memoire-triangle-vitesse.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Plus la mémoire est proche du processeur, plus elle est rapide, de faible capacité et chère.&lt;/p&gt;

&lt;h2 id=&#34;toc_60&#34;&gt;La mémoire vive (RAM)&lt;/h2&gt;

&lt;h3 id=&#34;toc_61&#34;&gt;Définition&lt;/h3&gt;

&lt;p&gt;La mémoire vive ou RAM (&lt;em&gt;Random Access Memory&lt;/em&gt;) est la principale mémoire de travail de l&amp;rsquo;ordinateur. Elle est &lt;strong&gt;volatile&lt;/strong&gt; : les données stockées en mémoire vive sont perdues à l&amp;rsquo;extinction de la machine. En contrepartie, la RAM est très rapide.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Estimez le débit des mémoires RAM actuelles.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Les informations sont stockés dans les composants de mémoire vive, sous forme de charges électriques dans de minuscules condensateurs. Un condensateur chargé représente un 1 et un condensateur non chargé représente un 0. Les condensateurs se décharger naturellement, il faut entretenir la charge périodiquement. Ce processus est appelé &lt;strong&gt;rafraîchissement de la mémoire&lt;/strong&gt;. La mémoire de ce type (nécessitant un rafraîchissement périodique) est appelée mémoire dynamique ou DRAM.&lt;/p&gt;

&lt;h3 id=&#34;toc_62&#34;&gt;Echanges avec le processeur&lt;/h3&gt;

&lt;p&gt;On peut envisager la mémoire vive comme un gigantesque ensemble de cases, que le processeur utilise pour stocker des informations. Les échanges entre RAM et processeur se font au travers de différents bus : commandes, adresses, données.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/memoire-echanges-proc.png&#34; class=&#34;content centered bordered&#34; alt=&#34;memoire-echanges-proc.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_63&#34;&gt;Format des barrettes de RAM&lt;/h3&gt;

&lt;p&gt;Il existe de nombreux types de mémoires vives. Celles-ci se présentent toutes sous la forme de barrettes de mémoire enfichables sur la carte-mère.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/memoire-ram.png&#34; class=&#34;content centered&#34; alt=&#34;memoire-ram.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les premières DRAM étaient de type asynchrone. Depuis 1997, elles sont synchrones(SD-RAM), elles échangent des données en se synchronisant avec le signal d’horloge. Depuis 2000, un nouveau standard est mis au point par Nec, Samsung et Toshiba : le DDR (&lt;em&gt;Double Data Rate&lt;/em&gt;). Cette technologie permet de &lt;strong&gt;doubler le taux de transfert&lt;/strong&gt; des DRAM. La technologie DDR2 est apparue en 2003, c’est une amélioration de DDR (débit plus important, consommation électrique réduite, dissipation thermique moins importante). La &lt;strong&gt;technologie DDR3&lt;/strong&gt; est apparue en 2007. Les améliorations apportées sont de la même nature que DDR2.&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;dénomination&lt;/strong&gt; d’une mémoire DDR est fonction de son type DDR,
DDR2, DDR3 et de sa fréquence. Par exemple une mémoire DDR fonctionnant
à 333 MHz aura comme dénomination DDR333.&lt;/p&gt;

&lt;h3 id=&#34;toc_64&#34;&gt;Quantité de RAM&lt;/h3&gt;

&lt;p&gt;La capacité des mémoires vives actuelles est exprimée en GigaOctets (Go). PLus cette capacité est importante, plus l&amp;rsquo;ordinateur peut exécuter d&amp;rsquo;applications en parallèle ou lancer des logiciels gourmands en RAM (retouche photo ou vidéo, jeux, etc).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Windows XP&lt;/strong&gt; nécessite un minimum de 256 Mo, de 512 Mo à 1 Go pour un usage bureautique, de 1 Go à 2 Go pour un usage avancé (retouche photo, montage vidéo, jeux).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Windows 7&lt;/strong&gt; nécessite plus de mémoire, 1 Go minimum, de 1 Go à 2 Go pour un usage bureautique, de 2 Go à 4 Go pour un usage avancé (retouche photo, montage vidéo, jeux).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/w7-proprietes-syst.png&#34; class=&#34;content centered bordered&#34; alt=&#34;w7-proprietes-syst.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_65&#34;&gt;Fréquence de la RAM&lt;/h3&gt;

&lt;p&gt;Comme nous l’avons vu dans le chapitre sur la carte mère, la mémoire RAM est synchronisée sur la vitesse du bus (le FSB : &lt;em&gt;Front Side Bus&lt;/em&gt;) de la carte mère dépendant du processeur qui l’équipe. Il convient donc d’utiliser des RAM se rapprochant le plus de cette fréquence sous peine que les performances soient diminuées. Pour un fonctionnement optimal, la RAM doit être &amp;ldquo;synchronisée&amp;rdquo; avec le processeur.&lt;/p&gt;

&lt;h3 id=&#34;toc_66&#34;&gt;Temps de latence&lt;/h3&gt;

&lt;p&gt;La latence d’une mémoire est le temps nécessaire pour réaliser une opération de lecture ou d’écriture. Plus la latence est faible plus la mémoire est réactive&amp;hellip; et plus son prix est élevé. La latence CAS (en anglais CAS Latence) permet d’évaluer les performances d’une mémoire. Le CAS Latence correspond au nombre de
cycles d’horloge nécessaires entre deux accès.&lt;/p&gt;

&lt;p&gt;Sur le marché, vous trouverez des barrettes mémoires avec les
appellations (CL2, CL2.5, CL3, CL4 ou CL5). CL est l’abréviation de CAS
Latence suivi du nombre de cycles d’horloge.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/memoire-latence.png&#34; class=&#34;content centered bordered&#34; alt=&#34;memoire-latence.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_67&#34;&gt;Correction d’erreurs&lt;/h3&gt;

&lt;p&gt;Les mémoires standard, installées dans nos PC sont des mémoires non-ECC. Cette abréviation précise qu’elles ne contiennent aucun système de correction d’erreur. Il existe sur le marché des barrettes mémoires de type ECC (&lt;em&gt;Error-Correcting Code&lt;/em&gt;) intégrant une technologie de correction d’erreur. Le mécanisme ECC détecte et corrige les erreurs ou les données corrompues. Ce type de mémoire est surtout utilisé pour les serveurs d’entreprise où la fiabilité et l’intégrité des données en mémoire vive sont très importantes.&lt;/p&gt;

&lt;p&gt;Il existe des barrettes de mémoire de 32 bits ou 36 bits. Une barrette de mémoire de 32 bits contient exactement la même quantité de données qu&amp;rsquo;une barrette de 36 bits. Les quatre bits supplémentaires ne servent qu&amp;rsquo;à contrôler la validité des huit bits qui les précèdent (un &lt;strong&gt;bit de parité&lt;/strong&gt; par groupe de huit bits). Le principe consiste à faire la somme des huit bits de données, puis à donner au neuvième la valeur 1 si le résultat est pair, et 0 si le résultat est impair. (On peut également faire le contraire. On parlera de &lt;strong&gt;parité paire&lt;/strong&gt; dans le premier cas, et de &lt;strong&gt;parité impaire&lt;/strong&gt; dans le second.)&lt;/p&gt;

&lt;p&gt;De cette façon, si un des bits change de valeur par accident, l&amp;rsquo;erreur sera repérable car le bit de parité ne correspondra plus au résultat. Il peut sembler que la sécurité ainsi obtenue ne soit pas de très haut niveau. En effet, si un deuxième bit change de valeur, la parité est de nouveau correcte. Cependant, s&amp;rsquo;il y a une chance sur mille (par exemple) qu&amp;rsquo;une erreur se produise sur un bit, il y aura une chance sur un million pour que deux bits soient erronés. La sécurité obtenue n&amp;rsquo;est donc pas négligeable. Toutefois, le bit de parité ne permet pas de retrouver le bit erroné.&lt;/p&gt;

&lt;h3 id=&#34;toc_68&#34;&gt;Technologie Dual Channel&lt;/h3&gt;

&lt;p&gt;Les processeurs modernes ont des besoins très élevés en bande passante. La technologie Dual Channel est une réponse à ces nouveaux besoins. Le principe est d’associer deux canaux à deux barrettes de mémoires DDR pour doubler le débit entre la mémoire et le processeur.&lt;/p&gt;

&lt;p&gt;Pour bénéficier de cette technologie, il faut que votre carte mère la supporte et installer deux barrettes de mémoire identiques dans les emplacements appropriés. Les emplacements Dual Channel sont d’une couleur différente du noir&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/memoire-dual-channel.png&#34; class=&#34;content centered bordered&#34; alt=&#34;memoire-dual-channel.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_69&#34;&gt;La mémoire morte (ROM)&lt;/h2&gt;

&lt;p&gt;Ce type de mémoire est non volatile mais plus lente que la mémoire vive. Elle est utilisée pour stocker les données indispensables au démarrage de l’ordinateur :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Le &lt;strong&gt;BIOS&lt;/strong&gt;, Basic Input/Output System, programme permettant de piloter les interfaces d&amp;rsquo;entrée-sortie principales du système&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Le &lt;strong&gt;Power-On Self Test&lt;/strong&gt; (POST), programme exécuté automatiquement à l&amp;rsquo;amorçage du système permettant de faire un test du système (comptage de la RAM par exemple).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/memoire-rom.png&#34; class=&#34;content centered bordered&#34; alt=&#34;memoire-rom.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les ROM ont évolué de mémoires mortes figées à des mémoires programmables, puis reprogrammables :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ROM : &lt;strong&gt;Read Only Memory&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PROM : &lt;strong&gt;Programmable ROM&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;EPROM : &lt;strong&gt;Erasable PROM&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;EEPROM : &lt;strong&gt;Electrically EPROM, effaçables par un courant électrique d’où le terme de flash&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;Flash qui est devenu un intermédiaire entre la mémoire morte initiale et la mémoire vive. Nous la reverrons avec les disques SSD (&lt;em&gt;Solid State Drive&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_70&#34;&gt;Le disque dur&lt;/h2&gt;

&lt;h3 id=&#34;toc_71&#34;&gt;Description&lt;/h3&gt;

&lt;p&gt;Le disque dur est un type de mémoire de masse (non volatile) encore très répandu.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/disque-dur-exterieur.png&#34; class=&#34;content centered&#34; alt=&#34;disque-dur-exterieur.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Il est constitué d&amp;rsquo;un ou plusieurs plateaux et d&amp;rsquo;un bras mobile sur lequel se trouvent les têtes de lecture. Chaque face du plateau est divisée en pistes circulaires concentriques. Chaque piste se divise en secteurs qui sont des portions de pistes limitées par deux rayons. En général, un secteur contient 512 octets.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/disque-dur-interieur.png&#34; class=&#34;content centered&#34; alt=&#34;disque-dur-interieur.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les disques durs sont des mécanismes de haute précision, sensibles au choc. L’électronique, aussi appelée &lt;strong&gt;contrôleur disque dur&lt;/strong&gt;, est chargée de piloter la rotation des plateaux ainsi que l’ensemble bras/tête pour
effectuer les lectures et les écritures. Son autre rôle est d’interpréter les signaux électriques reçus par les têtes pour les convertir en bits (0 ou 1) ou de réaliser l’opération dans le sens inverse pour les opérations d’écriture.&lt;/p&gt;

&lt;p&gt;Le nombre de plateaux varie de 1 à 5. Un nombre de plateaux important
est généralement nécessaire pour les disques durs de fortes capacités.&lt;/p&gt;

&lt;h3 id=&#34;toc_72&#34;&gt;Format&lt;/h3&gt;

&lt;p&gt;Il existe plusieurs formats de disques durs :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Format 1,8&amp;rdquo; : pour les ordinateurs ultraportables. Ses performances sont souvent modestes à cause de faibles vitesses de rotation : 4200 ou 5400 tours/min.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Format 2,5&amp;rdquo; : le format le plus courant pour les ordinateurs portables : 4200, 5400 et 7200 tours/min.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Format 3,5&amp;rdquo; : pour les ordinateurs de bureau et les serveurs. Ce sont les plus performants : 7200, 10000,15000 tours/min.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_73&#34;&gt;Mémoire cache&lt;/h3&gt;

&lt;p&gt;Cette mémoire de faible capacité permet d’améliorer les performances d’un disque dur en stockant les informations les plus souvent utilisées.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Quelle est la taille des mémoires cache embarquées sur les disques durs actuels ?&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;toc_74&#34;&gt;Interfaces avec l&amp;rsquo;ordinateur&lt;/h3&gt;

&lt;p&gt;Les interfaces internes (connexion à l&amp;rsquo;intérieur du boîtier de l&amp;rsquo;ordinateur) peuvent être :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ATA, également nommée PATA ou IDE. N’existe plus sur les DD récents.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SATA (&lt;em&gt;Serial ATA&lt;/em&gt;). Standard actuel.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SCSI (&lt;em&gt;Small Computer System Interface&lt;/em&gt;). Surtout utilisée pour les serveurs d’entreprise.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Les interfaces externes (connexion à l&amp;rsquo;extérieur du boîtier) sont :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;USB : les disques durs externes proposés sur le marché sont compatibles avec la norme 3.0.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;eSATA : version externe de la technologie SATA utilisée pour les disques internes.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_75&#34;&gt;Le disque SSD&lt;/h2&gt;

&lt;p&gt;À la différence d’un disque dur utilisant le principe magnétique, un disque SSD (&lt;em&gt;Solid State Drive&lt;/em&gt;) est constitué de &lt;strong&gt;puces de mémoires flash,&lt;/strong&gt; qui sont des puces électroniques possédant les caractéristiques d’une mémoire vive, mais dont les données ne disparaissent pas lors d’une mise hors tension. Ils ne contiennent donc aucune pièce mécanique.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/ssd.jpeg&#34; class=&#34;content centered&#34; alt=&#34;ssd.jpeg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les SSD présentent de nombreux avantages par rapport à un disque dur traditionnel :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Insensibilité aux chocs.&lt;/li&gt;
&lt;li&gt;Temps d’accès plus rapide.&lt;/li&gt;
&lt;li&gt;Fonctionnement totalement silencieux.&lt;/li&gt;
&lt;li&gt;Débits importants et stables.&lt;/li&gt;
&lt;li&gt;Probabilité de panne beaucoup plus faible, liée à l’absence de pièces mécaniques en mouvements.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En contrepartie, la technologie SSD a certaines inconvénients :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Prix beaucoup plus élevé que celui d’un disque dur à capacité égale. Les capacités des SSD sont aussi inférieures aux disques durs avec une capacité maximale autour de 1 To.&lt;/li&gt;
&lt;li&gt;Durée de vie limitée : une puce de mémoire ne fonctionnera plus au-delà d&amp;rsquo;un (grand) nombre de lecture/écriture. En répartissant les opérations de lecture/écriture sur l&amp;rsquo;ensemble du disque, la technologie &lt;a href=&#34;http://fr.wikipedia.org/wiki/TRIM&#34;&gt;TRIM&lt;/a&gt; permet de prolonger la durée de vie d&amp;rsquo;un SSD.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Question&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Combien coûte un SSD de 500 Go ? Et un disque dur de même capacité ?&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Les SSD sont vraisemblablement appelés à remplacer les disques durs dans un proche avenir.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction au développement Web</title>
      <link>http://prof.bpesquet.fr/cours/introduction-developpement-web</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/introduction-developpement-web</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce cours est d&amp;rsquo;acquérir les notions fondamentales liées au développement Web.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Ce cours s&amp;rsquo;inspire pour partie de la &lt;a href=&#34;http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html&#34;&gt;documentation du framework Symfony2&lt;/a&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Le fonctionnement du Web&lt;/h1&gt;

&lt;p&gt;Pour consulter un site Web sur Internet, il suffit de taper l&amp;rsquo;adresse correcte du site dans la barre d&amp;rsquo;adresse d&amp;rsquo;un navigateur Web, et le site s&amp;rsquo;affiche. Nous allons tenter de comprendre ce qui se cache derrière cette opération très simple en apparence.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;La notion de serveur Web&lt;/h2&gt;

&lt;p&gt;Pour être accessible, un site Web doit être publié sur un &lt;strong&gt;serveur&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un serveur est un type particulier d&amp;rsquo;ordinateur dont le rôle est d&amp;rsquo;attendre les demandes de clients, et d&amp;rsquo;y répondre. Un serveur rend un service à ses clients.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Il existe de nombreux types de serveurs, en fonction du service rendu : serveur de fichiers, de messagerie, d&amp;rsquo;authentification&amp;hellip; Un serveur qui permet de publier des sites Web est appelé serveur Web.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Une même machine peut rendre différents services (exemple : serveur Web et serveur de fichiers).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Plus précisément, une machine serveur Web embarque et exécute un logiciel serveur, capable de répondre aux demandes de consultations de sites Web. Les logiciels serveurs Web les plus populaires sont &lt;a href=&#34;http://httpd.apache.org/&#34;&gt;Apache&lt;/a&gt;, &lt;a href=&#34;http://www.iis.net/&#34;&gt;Microsoft IIS&lt;/a&gt; et &lt;a href=&#34;http://nginx.org/&#34;&gt;nginx&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;La notion de client Web&lt;/h2&gt;

&lt;p&gt;La machine qui permet la consultation du site Web demandé est appelé &lt;strong&gt;client Web&lt;/strong&gt;. Il s&amp;rsquo;agit d&amp;rsquo;un abus de langage : en réalité, le véritable client est un logiciel qui s&amp;rsquo;exécute sur cette machine et réalise l&amp;rsquo;opération de consultation. Ce logiciel est le plus souvent un navigateur Web (&lt;em&gt;browser&lt;/em&gt;). Les navigateurs Web les plus populaires sont &lt;a href=&#34;http://windows.microsoft.com/fr-fr/internet-explorer/&#34;&gt;Internet Explorer&lt;/a&gt;, &lt;a href=&#34;https://www.mozilla.org/fr/firefox&#34;&gt;Mozilla Firefox&lt;/a&gt;, &lt;a href=&#34;https://www.google.fr/chrome/browser/&#34;&gt;Chrome&lt;/a&gt;, &lt;a href=&#34;https://www.apple.com/fr/safari/&#34;&gt;Safari&lt;/a&gt; et &lt;a href=&#34;http://www.opera.com/fr&#34;&gt;Opera&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;D&amp;rsquo;autres types de logiciels que les navigateurs peuvent jouer le rôle de clients Web en se connectant à des serveurs Web. Exemples : robots d&amp;rsquo;indexation, aspirateurs Web, applications mobiles, etc.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;La communication entre client et serveur&lt;/h2&gt;

&lt;p&gt;La compréhension des échanges ayant lieu entre un client et un serveur Web lors de la consultation d&amp;rsquo;un site est essentielle. Il s&amp;rsquo;agit d&amp;rsquo;un mécanisme de type &lt;strong&gt;requête/réponse&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_http_echange.png&#34; class=&#34;content centered&#34; alt=&#34;web_http_echange.png&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;L&amp;rsquo;échange est initié par le client, qui envoie au serveur une requête pour consulter une ressource Web.&lt;/li&gt;
&lt;li&gt;Le serveur prépare la page HTML associée.&lt;/li&gt;
&lt;li&gt;Le serveur renvoie la page HTML au client, qui l&amp;rsquo;affiche.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Afin de se comprendre, client et serveur Web utilisent pendant leurs échanges un protocole commun : HTTP.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Le protocole HTTP&lt;/h2&gt;

&lt;p&gt;HTTP (&lt;em&gt;HyperText Transfert Protocol&lt;/em&gt;) est le protocole de transfert du Web. C&amp;rsquo;est son invention en 1989 au CERN de Genève, en même temps que le langage HTML, qui a conduit à l&amp;rsquo;apparition du World Wide Web : un immense réseau de réseaux, où on peut &amp;ldquo;rebondir&amp;rdquo; d&amp;rsquo;une page Web à une autre en utilisant des liens sans avoir besoin de connaître l&amp;rsquo;emplacement physique des serveurs et des ressources consultés.&lt;/p&gt;

&lt;p&gt;HTTP est fondamentalement un protocole très simple, basé sur des commandes textuelles.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;Anatomie d&amp;rsquo;une requête HTTP&lt;/h3&gt;

&lt;p&gt;Prenons comme exemple la première étape de l&amp;rsquo;échange décrit plus haut.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_http_requete.png&#34; class=&#34;content centered&#34; alt=&#34;web_http_requete.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La requête HTTP envoyée par le navigateur prend une forme similaire à celle-ci :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
Host: xkcd.com
Accept: text/html
User-Agent: Mozilla/5.0 (Macintosh)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La première ligne de cette requête HTTP est la plus importante. Elle contient :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;La &lt;strong&gt;méthode&lt;/strong&gt; associée à la requête : ici, &lt;code&gt;GET&lt;/code&gt; signifie une demande de ressource.&lt;/li&gt;
&lt;li&gt;L&amp;rsquo;identifiant de la &lt;strong&gt;ressource concernée&lt;/strong&gt;. Ici, &lt;code&gt;/&lt;/code&gt; (symbole de la racine, comme sous Linux) indique qu&amp;rsquo;on souhaite accéder au document par défaut.&lt;/li&gt;
&lt;li&gt;La &lt;strong&gt;version&lt;/strong&gt; du protocole HTTP, ici 1.1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Les autres lignes de la requête HTTP sont appelés champs d&amp;rsquo;en-tête (&lt;em&gt;HTTP header fields&lt;/em&gt; ou plus simplement &lt;em&gt;headers&lt;/em&gt;). Ils précisent le site Web concerné (champ &lt;code&gt;Host&lt;/code&gt;), les types de contenu acceptés par le client (champ &lt;code&gt;Accept&lt;/code&gt;) et le logiciel client utilisé (champ &lt;code&gt;User-Agent&lt;/code&gt;). Il existe d&amp;rsquo;autres champs d&amp;rsquo;en-tête, non présentés ici.&lt;/p&gt;

&lt;p&gt;Les méthodes HTTP les plus fréquemment utilisées sont &lt;code&gt;GET&lt;/code&gt; (pour récupérer une ressource depuis le serveur) et &lt;code&gt;POST&lt;/code&gt; (pour modifier une ressource sur le serveur). Il en existe d&amp;rsquo;autres comme &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; ou &lt;code&gt;DELETE&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;Anatomie d&amp;rsquo;une réponse HTTP&lt;/h3&gt;

&lt;p&gt;Lorsqu&amp;rsquo;il reçoit une requête HTTP, le serveur Web y puise les informations nécessaires pour construire la réponse, puis la renvoie au client. Continuons avec notre exemple précédent.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_http_echange.png&#34; class=&#34;content centered&#34; alt=&#34;web_http_echange.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La réponse HTTP renvoyée du serveur au client prend l&amp;rsquo;aspect ci-dessous.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 14 Apr 2013 14:05:05 GMT
Server: lighttpd/1.4.19
Content-Type: text/html

&amp;lt;html&amp;gt;
    &amp;lt;!-- code HTML de la page --&amp;gt;
    &amp;lt;!-- ... --&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La première ligne de la réponse contient son &lt;strong&gt;statut&lt;/strong&gt; sous la forme d&amp;rsquo;un code qui indique le résultat de la requête. Comme une requête, une réponse HTTP contient des champs d&amp;rsquo;en-tête (&lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Content-Type&lt;/code&gt; et bien d&amp;rsquo;autres) permettant de véhiculer des informations additionnelles. Par exemple, il est possible d&amp;rsquo;utiliser certains champs pour mettre en place un mécanisme de cache.&lt;/p&gt;

&lt;p&gt;Enfin, la réponse HTTP contient éventuellement la ressource demandée par le client. Le plus souvent, il s&amp;rsquo;agit d&amp;rsquo;une page Web décrite sous la forme de balises HTML.&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;Les codes HTTP&lt;/h3&gt;

&lt;p&gt;Les codes de retour HTTP peuvent être classés par familles en fonction du premier chiffre.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Famille&lt;/th&gt;
&lt;th&gt;Signification&lt;/th&gt;
&lt;th&gt;Exemples&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;1xx&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Information&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2xx&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Succès&lt;/td&gt;
&lt;td&gt;200 : requête traitée avec succès&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;3xx&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Redirection&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4xx&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Erreur provenant du client&lt;/td&gt;
&lt;td&gt;400 : syntaxe de la requête erronée&lt;br&gt;404 : ressource demandée non trouvée&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5xx&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Erreur provenant du serveur&lt;/td&gt;
&lt;td&gt;500 : erreur interne du serveur&lt;br&gt;503 : service temporairement indisponible&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/http_error_404.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;http_error_404.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vous trouverez sur &lt;a href=&#34;http://fr.wikipedia.org/wiki/Hypertext_Transfer_Protocol&#34;&gt;Wikipedia&lt;/a&gt; plus de détails sur le protocole HTTP.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;La notion d&amp;rsquo;adresse Web&lt;/h2&gt;

&lt;p&gt;On a l&amp;rsquo;habitude d&amp;rsquo;accéder à un site Web en utilisant son adresse. Celle-ci est de la forme :
&lt;a href=&#34;http://www.monsite.fr/mondossier/mapage.html&#34;&gt;http://www.monsite.fr/mondossier/mapage.html&lt;/a&gt;. On peut décomposer cette adresse en plusieurs sous-parties.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://&lt;/code&gt; signifie qu&amp;rsquo;on utilise le protocole HTTP.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;www.monsite.fr&lt;/code&gt; est le nom de domaine du site Web visité.&lt;/li&gt;
&lt;li&gt;`/mondossier/mapage.html est le chemin de la ressource demandée au sein du site.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La majorité des serveurs Web est configurée pour renvoyer une page par défaut (&lt;code&gt;index.html&lt;/code&gt;, &lt;code&gt;index.php&lt;/code&gt;, &lt;code&gt;Default.aspx&lt;/code&gt;) lorsque le client ne précise pas explicitement quelle page il souhaite récupérer (exemples : &lt;a href=&#34;http://www.monsite.fr&#34;&gt;http://www.monsite.fr&lt;/a&gt; ou &lt;a href=&#34;http://www.monsite.fr/mondossier/&#34;&gt;http://www.monsite.fr/mondossier/&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Une adresse Web telle que celle ci-dessus esr ce qu&amp;rsquo;on appelle une &lt;strong&gt;URL&lt;/strong&gt; ou &lt;em&gt;Uniform Resource Locator&lt;/em&gt;. Elle permet de décrire l&amp;rsquo;emplacement d&amp;rsquo;une ressource Web et le moyen d&amp;rsquo;y accéder.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Sites statiques et sites dynamiques&lt;/h1&gt;

&lt;p&gt;Les évolutions technologiques récentes ont rendu la frontière entre sites statiques et dynamiques de plus en plus floue. Ce paragraphe présente ces deux concepts de manière générale&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Anatomie d&amp;rsquo;un site Web statique&lt;/h2&gt;

&lt;p&gt;Un site Web statique se compose essentiellement de fichiers sources &lt;strong&gt;HTML&lt;/strong&gt; (pour le contenu des pages) et &lt;strong&gt;CSS&lt;/strong&gt; (pour la mise en forme). Il peut également intégrer d&amp;rsquo;autres types de ressources comme par exemple des images.&lt;/p&gt;

&lt;p&gt;La consultation d&amp;rsquo;un site Web statique met en jeu deux logiciels :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Le logiciel client, le plus souvent un navigateur Web.&lt;/li&gt;
&lt;li&gt;Le logiciel serveur Web.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lorsqu&amp;rsquo;un client envoie une requête au serveur Web hébergeant un site statique, le serveur se contente de la renvoyer la ressource demandée. Les pages HTML affichées ne peuvent pas évoluer automatiquement, d&amp;rsquo;où le terme &amp;ldquo;statique&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_site_statique.png&#34; class=&#34;content centered&#34; alt=&#34;web_site_statique.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;accès à un site Web statique est un exemple d&amp;rsquo;architecture &lt;strong&gt;client/serveur&lt;/strong&gt;, appelée également architecture &lt;strong&gt;deux tiers&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un &amp;ldquo;tier&amp;rdquo; correspond à un processus (programme en cours d&amp;rsquo;exécution) impliqué dans l&amp;rsquo;utilisation d&amp;rsquo;une application informatique.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;La mise à jour d&amp;rsquo;un site Web statique nécessite l&amp;rsquo;édition des fichiers sources, puis la mise en ligne des modifications (publication sur le serveur Web). Ce processus a plusieurs inconvénients :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Il nécessite des connaissances techniques : langages HTML et/ou CSS, méthode de publication d&amp;rsquo;un site, etc.&lt;/li&gt;
&lt;li&gt;Il devient vite contraignant dans le cas d&amp;rsquo;un site qui change fréquemment.&lt;/li&gt;
&lt;li&gt;Il est inadapté aux sites dont le contenu est enrichi par ses utilisateurs (&amp;ldquo;Web 2.0&amp;rdquo;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour toutes les raisons précédentes, on emploie un site statique lorsque le seul besoin est de présenter des informations au visiteur, sans aucune interactivité. On parle également de site vitrine.&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Anatomie d&amp;rsquo;un site Web dynamique&lt;/h2&gt;

&lt;p&gt;A l&amp;rsquo;inverse d&amp;rsquo;un site statique, un site dynamique est un type de site Web dans lequel le contenu des pages peut évoluer automatiquement.&lt;/p&gt;

&lt;p&gt;Lorsqu&amp;rsquo;un client envoie une requête au serveur Web hébergeant un site dynamique, le serveur prépare la page HTML correspondant à cette requête, puis la renvoie au client pour affichage. Les pages Web affichées au visiteur ne sont pas codées &amp;ldquo;en dur&amp;rdquo; comme dans le cas d&amp;rsquo;un site statique, mais &lt;strong&gt;générées&lt;/strong&gt; au moment de leur consultation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_site_dynamique.png&#34; class=&#34;content centered&#34; alt=&#34;web_site_dynamique.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les pages HTML obtenues peuvent être personnalisées en fonction du visiteur et/ou de données externes au site. Un cas très fréquent est celui où les pages Web renvoyées incluent des informations stockées dans une base de données. On obtient alors un exemple d&amp;rsquo;architecture &lt;strong&gt;trois tiers&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_3tiers.jpg&#34; class=&#34;content centered&#34; alt=&#34;web_3tiers.jpg&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
    &lt;strong&gt;Avertissement&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Il est très important de comprendre que le résultat renvoyé par le serveur Web et affiché par le client est toujours une page HTML.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Contrairement à un site statique, un site dynamique ouvre la voie à des interactions quasiment illimitées avec ses visiteurs : identification, échange de données entre site et utilisateur, mise à jour du site par ses utilisateurs&amp;hellip; Plus besoin de mettre à jour manuellement le code source des pages du site : il suffit que les données nécessaires soient stockées et accessibles par le serveur Web pour construire la page HTML affichée. Voici quelques types de sites Web dynamiques : sites de e-commerce, CMS, wikis, forums&amp;hellip;&lt;/p&gt;

&lt;p&gt;Un site Web dynamique se compose de pages HTML, de fichiers CSS et d&amp;rsquo;autres ressources comme des images, mais pas seulement. Il emploie nécessairement un langage capable de générer des pages HTML.&lt;/p&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Les langages serveur du Web dynamique&lt;/h2&gt;

&lt;p&gt;Lorsqu&amp;rsquo;on souhaite créer soi-même un site Web dynamique, on doit commencer par choisir le langage utilisé pour la génération des pages HTML. Le diagramme ci-dessous rassemble les principaux acteurs de ce marché.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_server_languages_chart.jpg&#34; class=&#34;content centered&#34; alt=&#34;web_server_languages_chart.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On constate que la technologie la plus populaire est PHP, suivie de loin par ASP.NET (Microsoft) et Java (ORACLE). PHP est particulièrement dominant dans le secteur des CMS (&lt;em&gt;Content Management System&lt;/em&gt;) qui permettent de publier du contenu en ligne sans presque aucune connaissance technique. On peut citer comme exemples Wordpress, Drupal ou Joomla.&lt;/p&gt;

&lt;p&gt;Quelle que soit la technologie mise en oeuvre, il est essentiel de bien comprendre que ces langages sont toujours employés côté serveur et jamais côté client (d&amp;rsquo;où le terme de langages &amp;ldquo;serveur&amp;rdquo;) Un navigateur Web ne sait pas exploiter directement une page PHP ou ASP.NET. En revanche, il sait afficher une page HTML qu&amp;rsquo;un serveur Web aura préalablement générée en utilisant PHP ou ASP.NET.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/web_php_htmlcss.png&#34; class=&#34;content centered&#34; alt=&#34;web_php_htmlcss.png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction à la programmation</title>
      <link>http://prof.bpesquet.fr/cours/introduction-programmation</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/introduction-programmation</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est de découvrir les notions fondamentales liées à la programmation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/evolution.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;evolution.jpg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Un programme, c&amp;rsquo;est quoi ?&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Le rôle d&amp;rsquo;un programme&lt;/h2&gt;

&lt;p&gt;Depuis son invention dans les années 1950, l&amp;rsquo;informatique a révolutionné bien des domaines de notre vie quotidienne. Le calcul d&amp;rsquo;un itinéraire depuis un site Internet ou un GPS, la réservation à distance d&amp;rsquo;un billet de train ou d&amp;rsquo;avion, ou encore la possibilité de voir et de parler avec des amis à l&amp;rsquo;autre bout du monde : tous ces actes courants sont possibles grâce aux &lt;strong&gt;ordinateurs&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Le terme &lt;strong&gt;ordinateur&lt;/strong&gt; est ici à prendre dans son sens le plus général, celui d&amp;rsquo;une &amp;ldquo;machine électronique capable d&amp;rsquo;exécuter des opérations arithmétiques et logiques&amp;rdquo; (&lt;a href=&#34;http://fr.wikipedia.org/wiki/Ordinateur&#34;&gt;Wikipedia&lt;/a&gt;). Il peut désigner aussi bien un ordinateur de bureau classique (PC, Mac) qu&amp;rsquo;un serveur de calcul ou encore un terminal mobile (tablette, &lt;em&gt;smartphone&lt;/em&gt;).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Cependant un ordinateur, même très performant, n&amp;rsquo;est qu&amp;rsquo;une &lt;strong&gt;machine&lt;/strong&gt; capable d&amp;rsquo;exécuter automatiquement une série d&amp;rsquo;opérations simples qu&amp;rsquo;on lui a demandées. Il ne dispose par lui-même d&amp;rsquo;aucune capacité d&amp;rsquo;apprentissage, de jugement, d&amp;rsquo;improvisation, bref d&amp;rsquo;aucune &amp;ldquo;intelligence&amp;rdquo;. Il se contente de &lt;strong&gt;faire ce qu&amp;rsquo;on lui dit de faire&lt;/strong&gt;. L&amp;rsquo;intérêt des ordinateurs est de savoir manipuler très rapidement et sans erreur d&amp;rsquo;énormes quantités d&amp;rsquo;informations.&lt;/p&gt;

&lt;p&gt;Une intervention humaine est nécessaire pour qu&amp;rsquo;un ordinateur puisse accomplir des tâches utiles. C&amp;rsquo;est le rôle du &lt;strong&gt;programmeur&lt;/strong&gt; (appelé également &lt;strong&gt;développeur&lt;/strong&gt;). Il va fournir les ordres que la machine doit exécuter en écrivant des programmes. De manière générale, un programme sert à &lt;strong&gt;automatiser un traitement sur des données&lt;/strong&gt;. Son résultat dépend des données qui lui sont fournies. On peut schématiser un programme de manière suivante : &lt;strong&gt;E-T-R&lt;/strong&gt; (Entrées–Traitements-Résultats). L&amp;rsquo;objectif du programmeur est donc d&amp;rsquo;écrire un programme qui, une fois exécuté par l&amp;rsquo;ordinateur, donnera les résultats attendus en fonction des données d&amp;rsquo;entrée.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un &lt;strong&gt;programme informatique&lt;/strong&gt; est une liste d&amp;rsquo;ordres indiquant à un ordinateur ce qu&amp;rsquo;il doit faire (&lt;a href=&#34;http://fr.wikipedia.org/wiki/Programme_informatique&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Création d&amp;rsquo;un programme&lt;/h2&gt;

&lt;p&gt;Pour créer des programmes informatiques, le programmeur utilise un &lt;strong&gt;langage de programmation&lt;/strong&gt;. Il en existe un grand nombre, par exemple C++, C#, Java, Python ou encore PHP. Un programme informatique se présente concrètement sous la forme d&amp;rsquo;un (ou le plus souvent plusieurs) fichiers texte, contenant des commandes spécifiques au langage : ce sont les ordres données à la machine, qu&amp;rsquo;on appelle également &lt;strong&gt;instructions&lt;/strong&gt;. L&amp;rsquo;ensemble des fichiers représente le &lt;strong&gt;code source&lt;/strong&gt; du programme. Chaque langage de programmation dispose de sa propre syntaxe et d&amp;rsquo;instructions spécifiques.&lt;/p&gt;

&lt;p&gt;Voici un exemple de programme très simple écrit en utilisant le langage
Python.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;Bonjour le monde.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On peut écrire le même programme en utilisant le langage PHP.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
echo(&amp;quot;Bonjour le monde.&amp;quot;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Même exemple avec le langage C#.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Program {
    static void Main(string[] args) {
        Console.WriteLine(&amp;quot;Bonjour le monde.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et voici le même programme, écrit cette fois en langage Java.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Program {
    public static void main(String[] args) {
        System.out.println(&amp;quot;Bonjour le monde.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tout éditeur de texte peut a priori permettre d&amp;rsquo;écrire des programmes. Pour gagner du temps lors de l&amp;rsquo;écriture du code source, les langages disposent de plate-formes d&amp;rsquo;édition très abouties appelées IDE (&lt;em&gt;Integrated Development Environment&lt;/em&gt;), comme par exemple Visual Studio ou Eclipse.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Exécution d&amp;rsquo;un programme&lt;/h2&gt;

&lt;p&gt;Le seul langage directement compréhensible par un ordinateur est le langage machine (ou &lt;strong&gt;assembleur&lt;/strong&gt;). Il s&amp;rsquo;agit d&amp;rsquo;instructions élémentaires liées à un type de processeur et qui permettent de manipuler directement la mémoire de la machine.&lt;/p&gt;

&lt;p&gt;Voici le programme précédent, réécrit en assembleur (&lt;a href=&#34;http://fr.wikipedia.org/wiki/Assembleur#Afficher_Bonjour&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str:
 .ascii &amp;quot;Bonjour le monde.\n&amp;quot;
 .global _start

_start:
movl $4, %eax
movl $1, %ebx
movl $str, %ecx
movl $19, %edx
int $0x80
movl $1, %eax
movl $0, %ebx
int $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;écriture de programmes en langage machine offre une rapidité maximale mais représente une tâche très complexe. Toute erreur peut se traduire par la corruption d&amp;rsquo;une zone mémoire, avec des conséquences parfois graves. Il s&amp;rsquo;agit donc d&amp;rsquo;un langage à réserver à des usages très spécifiques (écriture de pilotes pour un matériel, etc).&lt;/p&gt;

&lt;p&gt;Tout programme écrit dans un autre langage devra être &lt;strong&gt;traduit&lt;/strong&gt; en langage machine pour être exécuté par le processeur. Ce processus de traduction peut se faire de trois manières différentes et dépend du langage choisi.&lt;/p&gt;

&lt;p&gt;Par exemple, le programme Python précédent s&amp;rsquo;exécute en lançant la commande ci-dessous (on suppose que le fichier &lt;code&gt;bonjour.py&lt;/code&gt; contient les instructions du code source) :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python bonjour.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lors de l&amp;rsquo;appel de la commande ci-dessus, les instructions Python contenues dans ce fichier sont traduites en langage machine. Chaque ligne est exécutée au fur et à mesure de sa lecture : on dit que Python est un langage
&lt;a href=&#34;http://fr.wikipedia.org/wiki/Interpr%C3%A8te_(informatique&#34;&gt;interprété&lt;/a&gt;#Principe).&lt;/p&gt;

&lt;p&gt;Une autre possibilité consiste à créer à partir du code source un fichier directement exécutable (extension &lt;strong&gt;.exe&lt;/strong&gt; sous Windows), en utilisant un programme intermédiaire appelé &lt;a href=&#34;http://fr.wikipedia.org/wiki/Compilateur&#34;&gt;compilateur&lt;/a&gt;. Exemples de langages utilisant un compilateur : C, C++.&lt;/p&gt;

&lt;p&gt;Une troisième option consiste à utiliser un &lt;strong&gt;pseudo-compilateur&lt;/strong&gt; pour générer à partir du code source un ensemble de fichiers pouvant être exécutés sur n&amp;rsquo;importe quelle plate-forme supportant l&amp;rsquo;environnement. C&amp;rsquo;est le cas du langage Java et des langages de la plate-forme Microsoft .NET (VB.NET, C#).&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Apprendre à écrire des programmes&lt;/h1&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;La démarche&lt;/h2&gt;

&lt;p&gt;Sauf dans des cas très simples, on ne crée pas un programme en se lançant directement dans l&amp;rsquo;écriture du code source. En se précipitant sur sa machine, on court plusieurs risques :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ne pas traiter le problème dans son intégralité, en se concentrant sur une seule partie.&lt;/li&gt;
&lt;li&gt;se laisser guider par les contraintes du langage utilisé.&lt;/li&gt;
&lt;li&gt;aboutir à un programme fonctionnel mais peu lisible, peu performant et comportant beaucoup d&amp;rsquo;erreurs (&lt;strong&gt;bogues&lt;/strong&gt;). Dans ce cas, le temps gagné initialement sera perdu plusieurs fois à corriger ses défauts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il est donc d&amp;rsquo;abord nécessaire d&amp;rsquo;analyser le problème pour trouver la suite d&amp;rsquo;opérations à réaliser pour le résoudre. Cette analyse a pour objectif de décomposer le problème en plusieurs sous-problèmes plus simples.&lt;/p&gt;

&lt;p&gt;Prenons un exemple concret tiré de la vie courante (source : A. Tarlowski) : je souhaite me préparer un plat de pâtes. Quelles sont les étapes qui vont me permettre d&amp;rsquo;atteindre mon objectif ? On peut imaginer la solution ci-dessous.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Début&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sortir une casserole&lt;/li&gt;
&lt;li&gt;Mettre de l&amp;rsquo;eau dans la casserole&lt;/li&gt;
&lt;li&gt;Ajouter du sel&lt;/li&gt;
&lt;li&gt;Mettre la casserole sur le feu&lt;/li&gt;
&lt;li&gt;Tant que l&amp;rsquo;eau ne bout pas : attendre&lt;/li&gt;
&lt;li&gt;Sortir les pâtes du placard&lt;/li&gt;
&lt;li&gt;Verser les pâtes dans la casserole&lt;/li&gt;
&lt;li&gt;Tant que les pâtes ne sont pas cuites : attendre&lt;/li&gt;
&lt;li&gt;Verser les pâtes dans une passoire&lt;/li&gt;
&lt;li&gt;Egoutter les pâtes&lt;/li&gt;
&lt;li&gt;Verser les pâtes dans un plat&lt;/li&gt;
&lt;li&gt;Si les pâtes sont trop fades : ajouter du sel&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Fin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/recette.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;recette.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On constate qu&amp;rsquo;on arrive à l&amp;rsquo;objectif visé en déroulant un ensemble d&amp;rsquo;actions dans un ordre précis. On peut distinguer différents types d&amp;rsquo;actions : les &lt;strong&gt;actions simples&lt;/strong&gt; (&lt;code&gt;Sortir une casserole&lt;/code&gt;), des &lt;strong&gt;actions conditionnelles&lt;/strong&gt; (&lt;code&gt;Si&lt;/code&gt;) et des &lt;strong&gt;actions répétitives&lt;/strong&gt; (&lt;code&gt;Tant que&lt;/code&gt;). Nous avons employé une notation simple, compréhensible et indépendante de tout langage de programmation. En fait, nous venons d&amp;rsquo;écrire ce qu&amp;rsquo;on appelle un &lt;strong&gt;algorithme&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un &lt;strong&gt;algorithme&lt;/strong&gt; est une une suite ordonnée d&amp;rsquo;opérations permettant de résoudre un problème donné (&lt;a href=&#34;http://fr.wikipedia.org/wiki/Algorithme&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;L&amp;rsquo;algorithmique&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;avantage de la représentation d&amp;rsquo;un problème sous forme d&amp;rsquo;un algorithme est que cette représentation est compréhensible par un être humain et indépendante d&amp;rsquo;un quelconque langage. En revanche, elle ne permet pas
d&amp;rsquo;employer les particularités de tel ou tel langage.&lt;/p&gt;

&lt;p&gt;Un algorithme n&amp;rsquo;est pas directement exécutable par un ordinateur. Pour cela, il faut le traduire dans le langage de programmation choisi. C&amp;rsquo;est ce qu&amp;rsquo;on appelle la phase de &lt;strong&gt;codage&lt;/strong&gt; ou &lt;strong&gt;d&amp;rsquo;implémentation&lt;/strong&gt;.
Cependant, on peut très bien simuler l&amp;rsquo;exécution d&amp;rsquo;un algorithme par une sorte de &amp;ldquo;pseudo-machine&amp;rdquo; sachant exécuter ses opérations.&lt;/p&gt;

&lt;p&gt;Résoudre un problème sous la forme d&amp;rsquo;un algorithme permet de se détacher des particularités d&amp;rsquo;un langage informatique pour aboutir à une solution générale, qui pourra très bien être ensuite exprimée dans un (ou
plusieurs) langages. &lt;strong&gt;Apprendre à (bien) écrire des algorithmes est le moyen le plus efficace pour apprendre à (bien) programmer&lt;/strong&gt;, quel que soit le langage utilisé.&lt;/p&gt;

&lt;p&gt;Plus le problème à résoudre est complexe, plus la phase de recherche d&amp;rsquo;un l&amp;rsquo;algorithme adapté prend d&amp;rsquo;importance (et de temps !).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>La POO avec PHP en bref</title>
      <link>http://prof.bpesquet.fr/cours/poo-php-en-bref</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/poo-php-en-bref</guid>
      <description>

&lt;p&gt;Le langage PHP permet d&amp;rsquo;utiliser la programmation orientée objet, avec toutefois quelques spécificités par rapport à d&amp;rsquo;autres langages comme Java ou C#. Nous allons faire un tour d&amp;rsquo;horizon des possibilités de PHP en matière de POO au travers de l&amp;rsquo;exemple classique des comptes bancaires.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Exemple de mise en oeuvre&lt;/h1&gt;

&lt;p&gt;Voici la définition PHP d&amp;rsquo;une classe &lt;code&gt;CompteBancaire&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

class CompteBancaire
{
    private $devise;
    private $solde;
    private $titulaire;

    public function __construct($devise, $solde, $titulaire)
    {
        $this-&amp;gt;devise = $devise;
        $this-&amp;gt;solde = $solde;
        $this-&amp;gt;titulaire = $titulaire;
    }

    public function getDevise()
    {
        return $this-&amp;gt;devise;
    }

    public function getSolde()
    {
        return $this-&amp;gt;solde;
    }

    protected function setSolde($solde)
    {
        $this-&amp;gt;solde = $solde;
    }

    public function getTitulaire()
    {
        return $this-&amp;gt;titulaire;
    }

    public function crediter($montant) {
        $this-&amp;gt;solde += $montant;
    }

    public function __toString()
    {
        return &amp;quot;Le solde du compte de $this-&amp;gt;titulaire est de &amp;quot; .
            $this-&amp;gt;solde . &amp;quot; &amp;quot; . $this-&amp;gt;devise;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En complément, voici la définition d&amp;rsquo;une classe &lt;code&gt;CompteEpargne&lt;/code&gt; qui hérite de la classe &lt;code&gt;CompteBancaire&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

require_once &#39;CompteBancaire.php&#39;;

class CompteEpargne extends CompteBancaire
{
    private $tauxInteret;

    public function __construct($devise, $solde, $titulaire, $tauxInteret)
    {
        parent::__construct($devise, $solde, $titulaire);
        $this-&amp;gt;tauxInteret = $tauxInteret;
    }

    public function getTauxInteret()
    {
        return $this-&amp;gt;tauxInteret;
    }

    public function calculerInterets($ajouterAuSolde = false)
    {
        $interets = $this-&amp;gt;getSolde() * $this-&amp;gt;tauxInteret;
        if ($ajouterAuSolde == true)
            $this-&amp;gt;setSolde($this-&amp;gt;getSolde() + $interets);
        return $interets;
    }

    public function __toString()
    {
        return parent::__toString() . 
            &#39;. Son taux d\&#39;interet est de &#39; . $this-&amp;gt;tauxInteret * 100 . &#39;%.&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;L&amp;rsquo;instruction &lt;a href=&#34;http://php.net/manual/fr/function.require-once.php&#34;&gt;require_once&lt;/a&gt; est similaire à &lt;a href=&#34;http://php.net/manual/fr/function.require.php&#34;&gt;require&lt;/a&gt; mais n&amp;rsquo;inclut le fichier demandé qu&amp;rsquo;une seule fois. Elle est utile pour éviter, comme ici, les définitions multiples de classes.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Voici un exemple d&amp;rsquo;utilisation de ces deux classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

require &#39;CompteBancaire.php&#39;;
require &#39;CompteEpargne.php&#39;;

$compteJean = new CompteBancaire(&amp;quot;euros&amp;quot;, 150, &amp;quot;Jean&amp;quot;);
echo $compteJean . &#39;&amp;lt;br /&amp;gt;&#39;;
$compteJean-&amp;gt;crediter(100);
echo $compteJean . &#39;&amp;lt;br /&amp;gt;&#39;;

$comptePaul = new CompteEpargne(&amp;quot;dollars&amp;quot;, 200, &amp;quot;Paul&amp;quot;, 0.05);
echo $comptePaul . &#39;&amp;lt;br /&amp;gt;&#39;;
echo &#39;Interets pour ce compte : &#39; . $comptePaul-&amp;gt;calculerInterets() . 
    &#39; &#39; . $comptePaul-&amp;gt;getDevise() . &#39;&amp;lt;br /&amp;gt;&#39;;
$comptePaul-&amp;gt;calculerInterets(true);
echo $comptePaul . &#39;&amp;lt;br /&amp;gt;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enfin, voici le résultat de son exécution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/poo-php-comptesbancaires.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;poo-php-comptesbancaires.jpg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Caractéristiques du modèle objet de PHP&lt;/h1&gt;

&lt;p&gt;L&amp;rsquo;observation des exemples précédents nous permet de retrouver certains concepts bien connus de la POO, repris par PHP :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;une &lt;strong&gt;classe&lt;/strong&gt; se compose d&amp;rsquo;&lt;strong&gt;attributs&lt;/strong&gt; et de &lt;strong&gt;méthodes&lt;/strong&gt; ;&lt;/li&gt;
&lt;li&gt;le mot-clé &lt;code&gt;class&lt;/code&gt; permet de définir une classe ;&lt;/li&gt;
&lt;li&gt;les différents niveaux d&amp;rsquo;accessibilité sont &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; et &lt;code&gt;private&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;le mot-clé &lt;code&gt;extends&lt;/code&gt; permet de définir une classe dérivée (comme en Java) ;&lt;/li&gt;
&lt;li&gt;le mot-clé &lt;code&gt;$this&lt;/code&gt; permet d&amp;rsquo;accéder aux membres de l&amp;rsquo;objet courant.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Spécificités du modèle objet de PHP&lt;/h1&gt;

&lt;p&gt;Même s&amp;rsquo;il est similaire à ceux de C#, Java ou C++, le modèle objet de PHP possède certaines particularités  :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PHP étant un langage à typage dynamique, on ne précise pas les types des attributs et des méthodes, mais seulement leur niveau d&amp;rsquo;accessibilité ;&lt;/li&gt;
&lt;li&gt;le mot-clé &lt;code&gt;function&lt;/code&gt; permet de déclarer une méthode, quelle que soit son type de retour ;&lt;/li&gt;
&lt;li&gt;le mot-clé &lt;code&gt;parent&lt;/code&gt; permet d&amp;rsquo;accéder au parent de l&amp;rsquo;objet courant. Il joue en PHP le même rôle que &lt;code&gt;base&lt;/code&gt; en C# et &lt;code&gt;super&lt;/code&gt; en Java ;&lt;/li&gt;
&lt;li&gt;le constructeur d&amp;rsquo;une classe s&amp;rsquo;écrit &lt;code&gt;__construct&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;la méthode &lt;code&gt;__toString&lt;/code&gt; détermine comment l&amp;rsquo;objet est affiché en tant que chaîne de caractères ;&lt;/li&gt;
&lt;li&gt;on peut redéfinir (&lt;em&gt;override&lt;/em&gt;) une méthode, comme ici &lt;code&gt;__toString&lt;/code&gt;, sans mot-clé particulier ;&lt;/li&gt;
&lt;li&gt;il est possible de définir une valeur par défaut pour les paramètres d&amp;rsquo;une méthode. Elle est utilisée lorsque l&amp;rsquo;argument (paramètre effectif) n&amp;rsquo;est pas précisé au moment de l&amp;rsquo;appel.
Remarques :&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-danger&#34;&gt;
    &lt;strong&gt;Danger !&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;L&amp;rsquo;utilisation de &lt;code&gt;$this-&amp;gt;&lt;/code&gt; est &lt;strong&gt;obligatoire&lt;/strong&gt; pour accéder aux membres de l&amp;rsquo;objet courant. Son utilisation est optionnelle en C# et en Java, et souvent limitée à la levée des ambiguïtés entre attributs et paramètres ;&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt; 

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Les méthodes &lt;code&gt;__construct&lt;/code&gt; et &lt;code&gt;__toString&lt;/code&gt; font partie de ce qu&amp;rsquo;on appelle les &lt;a href=&#34;http://php.net/manual/fr/language.oop5.magic.php&#34;&gt;méthodes magiques PHP&lt;/a&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>La norme HTML5 en bref</title>
      <link>http://prof.bpesquet.fr/cours/html5-en-bref</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/html5-en-bref</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Présentation&lt;/h1&gt;

&lt;p&gt;Le langage HTML (&lt;em&gt;HyperText Markup Language&lt;/em&gt;) a été inventé pour décrire une page Web. Il emploie des balises structurantes. Le terme HTML5 regroupe un ensemble d&amp;rsquo;évolutions du langage HTML visant à enrichir le langage pour faciliter l&amp;rsquo;écriture de clients Web riches tout en maintenant une rétrocompatibilité optimale avec l&amp;rsquo;existant.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/html5_logo.png&#34; class=&#34;content centered&#34; alt=&#34;html5_logo.png&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Support par les navigateurs actuels&lt;/h1&gt;

&lt;p&gt;HTML5 n&amp;rsquo;est pas encore un standard officiel et aucun navigateur n&amp;rsquo;offre un support exhaustif de la norme (dont certaines parties sont de toute façon susceptibles d&amp;rsquo;être modifiées&amp;hellip;). A moins d&amp;rsquo;être dans un contexte Intranet, le développeur Web ne maîtrise pas le choix du navigateur utilisé par les utilisateurs qui visitent son site.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/html5_browser_support.png&#34; class=&#34;content centered&#34; alt=&#34;html5_browser_support.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Il faut savoir que des versions antérieures d&amp;rsquo;Internet Explorer, notamment la tristement fameuse version 6, sont toujours utilisées par une part non négligeable des utilisateurs de Web.&lt;/p&gt;

&lt;p&gt;Cela dit, tous les éditeurs de navigateurs améliorent le support à chaque nouvelle version de leur logiciel. Il est également possible d&amp;rsquo;utiliser des bibliothèques Javascript comme Modernizr ou html5shiv qui émulent les nouvelles fonctionnalités sur les anciens navigateurs. Plusieurs sites inventorient l&amp;rsquo;état du support des différentes parties de la norme et permettent au développeur Web de savoir à quoi s&amp;rsquo;attendre.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://html5test.com&#34;&gt;http://html5test.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://caniuse.com&#34;&gt;http://caniuse.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://html5readiness.com&#34;&gt;http://html5readiness.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le site &lt;a href=&#34;http://html5please.com&#34;&gt;http://html5please.com&lt;/a&gt; est particulièrement intéressant, puisqu&amp;rsquo;il fournit de précieux conseils sur les éléments de la norme prêts à être utilisés en production et ceux qu&amp;rsquo;il vaut mieux laisser mûrir.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Quelques nouveautés de HTML5&lt;/h1&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Les balises sectionnantes&lt;/h2&gt;

&lt;p&gt;Lorsqu&amp;rsquo;on voulait réaliser une mise en page moderne avec la version précédente d&amp;rsquo;HTML, on devait utiliser abondamment l&amp;rsquo;élément &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (associé à une feuille de style) afin de définir les différentes parties de la page et leurs positions respectives.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;en_tete&amp;quot;&amp;gt;
    &amp;lt;!-- Bannière --&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div id=&amp;quot;menu&amp;quot;&amp;gt;
    &amp;lt;!-- Menu de navigation --&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div id=&amp;quot;corps&amp;quot;&amp;gt;
    &amp;lt;!-- Contenu principal de la page --&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div id=&amp;quot;pied_de_page&amp;quot;&amp;gt;
    &amp;lt;!-- Nom de l&#39;auteur... --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/html_div_layout.jpg&#34; class=&#34;content centered&#34; alt=&#34;html_div_layout.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;HTML5 a pris en compte ce besoin récurrent et apporte de nouvelles balises pour y répondre. Elles permettent de mettre en forme une page Web comme décrit ci-dessous.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/html5_sematic_layout.jpg&#34; class=&#34;content centered&#34; alt=&#34;html5_sematic_layout.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les informations de l&amp;rsquo;en-tête, ou la bannière sont placées à l&amp;rsquo;intérieur de la balise &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;. Dans cette partie, on peut placer des  images, des liens, des textes…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;header&amp;gt;
    &amp;lt;!-- contenu de l&#39;en-tête de la page --&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les principaux liens de navigation sont regroupés dans la balise &lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;.  Généralement, le menu est réalisé sous forme de liste à puces à l&amp;rsquo;intérieur de la balise.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;nav&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;index.html&amp;quot;&amp;gt;Accueil&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;contact.html&amp;quot;&amp;gt;Contact&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;pagebts.html&amp;quot;&amp;gt;BTS SIO&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;equipe.html&amp;quot;&amp;gt;L&#39;équipe&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La balise &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; sert à découper une page Web en plusieurs sous-parties : introduction, news, chapitres, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;section&amp;gt;
    &amp;lt;h1&amp;gt;Voici une section de page&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;et mon contenu de section&amp;lt;/p&amp;gt;
&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La balise &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt; contient des informations complémentaires à la page, placées par exemple sur le coté droit (une explication complémentaire, une photo, etc).  On peut  avoir plusieurs blocs &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt; dans la page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;aside&amp;gt;
    &amp;lt;!-- informations complémentaires --&amp;gt;
&amp;lt;/aside&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La balise &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; contient une partie autonome de la page, par exemple des actualités. Un article est susceptible d&amp;rsquo;être syndiqué via un flux RSS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;article&amp;gt;
    &amp;lt;h1&amp;gt;Mon article&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;rédaction …&amp;lt;/p&amp;gt;
&amp;lt;/article&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les informations du pied de page sont placées à l&amp;rsquo;intérieur de la balise &lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;. On y trouve des informations comme des liens de contact, le nom de l&amp;rsquo;auteur, les mentions légales, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;footer&amp;gt;
    &amp;lt;!-- contenu du pied de page --&amp;gt;
&amp;lt;/footer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ces nouvelles balises rendent la mise en page du site plus lisible, améliorent son rendu sur les différents types de terminaux Web (tablettes, smartphones, etc) et facilitent l&amp;rsquo;indexation du contenu de la page par les moteurs de recherche.&lt;/p&gt;

&lt;p&gt;Cependant; l&amp;rsquo;usage de balises &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; pour la mise en page reste toujours possible, comme dans l&amp;rsquo;exemple ci-dessous. Il illustre le cas où une page ne comporte qu&amp;rsquo;une seule section de contenu.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/html5_div_layout.jpg&#34; class=&#34;content centered&#34; alt=&#34;html5_div_layout.jpg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Les balises sémantiques&lt;/h2&gt;

&lt;p&gt;HTML5 apporte également de nouvelles balises destinées à donner plus de sémantique (plus de sens, de signification) à vos pages Web. Cela permet une meilleure compréhension de votre code par les humains et les machines (navigateurs Web, moteurs de recherche, etc).&lt;/p&gt;

&lt;p&gt;Citons par exemple la balise &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; qui permet d&amp;rsquo;indiquer une date/heure dans une page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;time datetime=&amp;quot;2012-11-08&amp;quot;&amp;gt;8 Novembre 2012&amp;lt;/time&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;attribut &lt;code&gt;datetime&lt;/code&gt; permet de faire comprendre aux machines la vraie date, afin de faciliter les opérations d&amp;rsquo;affichage, de tri, etc. Le contenu de la balise représente le texte affiché à l&amp;rsquo;utilisateur.&lt;/p&gt;

&lt;p&gt;Il en existe d&amp;rsquo;autres, par exemple &lt;code&gt;&amp;lt;figure&amp;gt;&lt;/code&gt; qui définit une illustration accompagnée de la légende.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Les formulaires enrichis&lt;/h2&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;Nouveaux champs de saisie&lt;/h3&gt;

&lt;p&gt;Voici quelques-uns des nouveaux types de champs utilisables dans les formulaires HTML5 :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;email&lt;/li&gt;
&lt;li&gt;search&lt;/li&gt;
&lt;li&gt;tel&lt;/li&gt;
&lt;li&gt;url&lt;/li&gt;
&lt;li&gt;date&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;li&gt;color&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chacun permet de saisir une donnée du type associé : un champ &lt;code&gt;email&lt;/code&gt; permettra de saisir une adresse de courriel, un champ &lt;code&gt;date&lt;/code&gt; permettra de saisir une date, etc. Ces nouveaux champs améliorent l&amp;rsquo;ergonomie des formulaires Web en les rapprochant des formulaires qu&amp;rsquo;on peut trouver sur un client lourd. Certains disposent d&amp;rsquo;attributs supplémentaires qui restreignent les possibilités de saisie, comme dans cet exemple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;number&amp;quot; min=&amp;quot;0&amp;quot; max=&amp;quot;100&amp;quot; step=&amp;quot;5&amp;quot; value=&amp;quot;50&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voici son rendu sur votre navigateur : &lt;input type=&#34;number&#34; min=&#34;0&#34; max=&#34;100&#34; step=&#34;5&#34; value=&#34;50&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ici, l&amp;rsquo;utilisateur pourra saisir un nombre compris entre 0 et 100. La valeur initiale du champ sera 50 et elle augmentera ou diminuera par pas de 5.&lt;/p&gt;

&lt;p&gt;La page &lt;a href=&#34;http://html5demo.braincracking.org/demo/input.php&#34;&gt;http://html5demo.braincracking.org/demo/input.php&lt;/a&gt; fournit une démonstration de l&amp;rsquo;utilisation de ces champs.&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
    &lt;strong&gt;Avertissement&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Le rendu de ces nouveaux champs varie assez fortement d&amp;rsquo;un navigateur à l&amp;rsquo;autre.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;Aide à la saisie&lt;/h3&gt;

&lt;p&gt;Deux attributs des balises de saisie permettent d&amp;rsquo;aider l&amp;rsquo;utilisateur du formulaire :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;autofocus&lt;/code&gt; (booléen) place le focus sur le champ au chargement du formulaire.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;placeholder&lt;/code&gt; définit le contenu par défaut du champ.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;email&amp;quot; autofocus placeholder=&amp;quot;utilisateur@domaine.fr&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Les attributs booléens sont une autre nouveauté de HTML5.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;Validation des entrées&lt;/h3&gt;

&lt;p&gt;Si la validation finale des valeurs saisies dans un formulaire doit toujours se faire côté serveur (par exemple avec PHP) pour des raisons de sécurité, HTML5 permet de mieux guider l&amp;rsquo;utilisateur dans sa saisie sans avoir besoin de recourir au Javascript ou à d&amp;rsquo;autres bibliothèques.&lt;/p&gt;

&lt;p&gt;Pour commencer, les nouveaux champs de saisie impliquent une restriction automatique des valeurs qu&amp;rsquo;il est possible d&amp;rsquo;entrer. Par exemple, voici la définition d&amp;rsquo;un champ de type courriel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;email&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si l&amp;rsquo;utilisateur saisit une chaîne non conforme au format d&amp;rsquo;une adresse de courriel, le navigateur compatible avec HTML5 affichera un message d&amp;rsquo;erreur.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/html5_email_validation.jpg&#34; class=&#34;content centered&#34; alt=&#34;html5_email_validation.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Il est également possible de rendre un champ obligatoire grâce à l&amp;rsquo;attribut booléen &lt;code&gt;required&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;email&amp;quot; required /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Le langage PHP en bref</title>
      <link>http://prof.bpesquet.fr/cours/php-en-bref</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/php-en-bref</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Commençons par une définition de PHP issue de Wikipedia :&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;PHP: Hypertext Preprocessor, plus connu sous son sigle PHP (acronyme récursif), est un langage de scripts libre principalement utilisé pour produire des pages Web dynamiques via un serveur HTTP, mais pouvant également fonctionner comme n&amp;rsquo;importe quel langage interprété de façon locale, en exécutant les programmes en ligne de commande. PHP dispose depuis la version 5 de fonctionnalités objet complètes. En raison de la richesse de sa bibliothèque, on désigne parfois PHP comme une plate-forme plus qu&amp;rsquo;un simple langage.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Il y a beaucoup d&amp;rsquo;informations dans ces quelques lignes, les plus importantes sont mises en évidence dans le texte :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PHP est un langage &lt;strong&gt;libre&lt;/strong&gt; (et gratuit).&lt;/li&gt;
&lt;li&gt;Il est principalement utilisé sur le Web pour générer des pages &lt;strong&gt;dynamiques&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;C&amp;rsquo;est un langage &lt;strong&gt;interprété&lt;/strong&gt; et non compilé comme Java ou C#.&lt;/li&gt;
&lt;li&gt;Depuis la version 5, il peut être utilisé de manière &lt;strong&gt;orientée objet&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Il existe autour de PHP un &lt;strong&gt;écosystème&lt;/strong&gt; très riche (bibliothèques, CMS, frameworks, etc).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Histoire de PHP&lt;/h1&gt;

&lt;p&gt;Le langage PHP fut créé en 1994 par Rasmus Lerdorf pour son site web. C&amp;rsquo;était à l&amp;rsquo;origine une bibliothèque logicielle écrite d&amp;rsquo;abord en langage Perl, pluis en langage C. Il s&amp;rsquo;en servait pour conserver une trace des visiteurs qui venaient consulter son CV. PHP signifiait alors Personal Home Page tools. Le code source de PHP fut publié par son auteur en 1996. En 1997, deux étudiants, Andi Gutmans et Zeev Suraski, redéveloppèrent le cœur de PHP puis son moteur interne, aboutissant à ce qu&amp;rsquo;on appelle le Zend Engine.&lt;/p&gt;

&lt;p&gt;Les versions du langage se sont succédées depuis, apportant leur lot d&amp;rsquo;améliorations et corrigeant les (nombreuses) failles de sécurité apparues en chemin. La version 5 de PHP, sortie en 2004, utilise Zend Engine 2 et introduit un véritable modèle objet, une gestion des erreurs fondée sur le modèle des exceptions, ainsi que des fonctionnalités de gestion pour les entreprises.&lt;/p&gt;

&lt;p&gt;Contrairement à des langages comme Java et C#, pensés par des armées d&amp;rsquo;ingénieurs chez Sun Microsystems et Microsoft, PHP a émergé du Web à partir d&amp;rsquo;une idée personnelle, puis a évolué au fur et à mesure des besoins. Cela explique le côté un peu confus du langage et certaines mauvaises décisions de design, qui ont eu des conséquences néfastes en termes de sécurité. C&amp;rsquo;est aussi pour cela que l&amp;rsquo;offre logicielle autour de PHP est si riche et adaptée à pratiquement tous les besoins.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Fonctionnement de PHP&lt;/h1&gt;

&lt;p&gt;Même s&amp;rsquo;il peut être utilisé en ligne de commande, PHP est principalement associé à un serveur Web utilisant le protocole HTTP dans le cadre d&amp;rsquo;une architecture client/serveur.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/php_fonctionnement.png&#34; class=&#34;content centered&#34; alt=&#34;php_fonctionnement.png&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Le client, le plus souvent un navigateur Web, fait la demande au serveur d&amp;rsquo;une page PHP au travers du protocole HTTP.&lt;/li&gt;
&lt;li&gt;Le serveur HTTP envoie la page PHP à son interpréteur.&lt;/li&gt;
&lt;li&gt;L&amp;rsquo;interprétation de la page PHP produit une page HTML de résultat fournie au serveur.&lt;/li&gt;
&lt;li&gt;Le serveur Web renvoie cette page au client pour affichage.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;alert alert-danger&#34;&gt;
    &lt;strong&gt;Danger !&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Attention à ne pas ouvrir directement une page PHP dans un navigateur (URL de type &lt;code&gt;file://&lt;/code&gt;) au lieu d&amp;rsquo;en faire la demande à un serveur Web (URL de type &lt;code&gt;http://&lt;/code&gt;).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Souvent, le code de la page PHP utilise les données stockées dans une base de données afin de générer le résultat HTML. On se trouve alors en présence d&amp;rsquo;une architecture &lt;strong&gt;trois-tiers&lt;/strong&gt; (navigateur Web, serveur Web/interpréteur PHP, SGBD). Les tiers serveur Web et SGBD peuvent être hébergés sur des machines distinctes ou regroupés sur une machine unique. Dans ce cas d&amp;rsquo;une machine unique sous Linux avec Apache comme serveur Web et MySQL comme SGBD, on obtient ce qu&amp;rsquo;on appelle un serveur &lt;strong&gt;LAMP&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Principales caractéristiques de PHP&lt;/h1&gt;

&lt;p&gt;La page PHP ci-dessous offre un aperçu des principales caractéristiques du langage.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;fr&amp;quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
        &amp;lt;title&amp;gt;Ma page de démonstration PHP&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;?php
        $prenom = &amp;quot;Bill&amp;quot;;
        $classe = &#39;BTS SIO&#39;;
        $langages = array(&#39;C#&#39;, &#39;Java&#39;, &#39;ASP.NET&#39;, &#39;PHP&#39;);
        $nbLangages = count($langages);
        $qualite = &amp;quot;débutant&amp;quot;;
        if ($nbLangages == 4) {
            $qualite = &amp;quot;débrouillé&amp;quot;;
        }
        elseif ($nbLangages &amp;gt; 4) {
            $qualite = &amp;quot;aguerri&amp;quot;;
        }
        ?&amp;gt;
        &amp;lt;h1&amp;gt;Ma présentation&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;Bonjour, je m&#39;appelle &amp;lt;?php echo &amp;quot;$prenom&amp;quot; ?&amp;gt; et je suis en &amp;lt;?php echo &amp;quot;$classe&amp;quot; ?&amp;gt;.&amp;lt;/p&amp;gt;
        &amp;lt;?php
        echo &#39;Je suis un programmeur &#39; . $qualite . &#39;. &#39;;
        echo &#39;Je connais &#39; . $nbLangages . &#39; langages de programmation :&amp;lt;/p&amp;gt;&#39;;
        ?&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;?php
            foreach ($langages as $langage) {
                echo &amp;quot;&amp;lt;li&amp;gt;$langage&amp;lt;/li&amp;gt;&amp;quot;;
            }
            ?&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On peut faire les observations suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;On définit une portion de code PHP gràce aux balises &lt;code&gt;&amp;lt;?php&lt;/code&gt; et &lt;code&gt;?&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Les variables sont préfixées par le symbole &lt;code&gt;$&lt;/code&gt; et leur typage est dynamique, contrairement à des langages comme C# ou Java où le typage est statique.&lt;/li&gt;
&lt;li&gt;On peut construire un résultat HTML en mélangeant balises HTML et code PHP, ou bien en utilisant l&amp;rsquo;instruction PHP &lt;code&gt;echo&lt;/code&gt; pour générer les balises HTML.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Compléments sur PHP&lt;/h1&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Affichage abrégé&lt;/h2&gt;

&lt;p&gt;Dans une page PHP, il est possible de remplacer &lt;code&gt;&amp;lt;?php echo ... ?&amp;gt;&lt;/code&gt; par &lt;code&gt;&amp;lt;?= ... ?&amp;gt;&lt;/code&gt; pour un résultat identique. Cette alternative à &lt;code&gt;echo&lt;/code&gt; permet d&amp;rsquo;alléger le code de la page PHP. Elle est surtout utile dans les pages qui mélangent PHP et HTML. Voici un extrait de la page précédente, réécrit en utilisant cette syntaxe.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$prenom = &amp;quot;Bill&amp;quot;;
$classe = &#39;BTS SIO&#39;;
?&amp;gt;
&amp;lt;h1&amp;gt;Ma présentation&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Bonjour, je m&#39;appelle &amp;lt;?= $prenom ?&amp;gt; et je suis en &amp;lt;?= $classe ?&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Depuis PHP 5.4, cette syntaxe est toujours disponible. Avec les versions précédentes, elle nécessite l&amp;rsquo;activation de la directive &lt;code&gt;short_open_tag&lt;/code&gt; dans le fichier de configuration de PHP.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Syntaxe alternative pour les structures de contrôle&lt;/h2&gt;

&lt;p&gt;PHP propose une autre manière de rassembler des instructions à l&amp;rsquo;intérieur d&amp;rsquo;un bloc, pour les structures de contrôle &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt; et &lt;code&gt;switch&lt;/code&gt;. Dans chaque cas, le principe est de remplacer l&amp;rsquo;accolade d&amp;rsquo;ouverture par deux points (&lt;code&gt;:&lt;/code&gt;) et l&amp;rsquo;accolade de fermeture par, respectivement, &lt;code&gt;endif;&lt;/code&gt;, &lt;code&gt;endwhile;&lt;/code&gt;, &lt;code&gt;endfor;&lt;/code&gt;, &lt;code&gt;endforeach;&lt;/code&gt; ou &lt;code&gt;endswitch;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Voici le même exemple écrit avec la syntaxe classique puis la syntaxe alternative.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php if (!isset($user)) { ?&amp;gt;
    &amp;lt;p&amp;gt;Veuillez vous connecter&amp;lt;/p&amp;gt;
&amp;lt;?php }
else { ?&amp;gt;
    &amp;lt;h2&amp;gt;Bienvenue &amp;lt;?= $user ?&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;Vous avez &amp;lt;?= count($messages) ?&amp;gt; messages en attente&amp;lt;/span&amp;gt;
    &amp;lt;?php foreach ($messages as $message) { ?&amp;gt;
        &amp;lt;p&amp;gt;&amp;lt;?= $message ?&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;?php } ?&amp;gt;
&amp;lt;?php } ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php if (!isset($user)): ?&amp;gt;
    &amp;lt;p&amp;gt;Veuillez vous connecter&amp;lt;/p&amp;gt;
&amp;lt;?php else: ?&amp;gt;
    &amp;lt;h2&amp;gt;Bienvenue &amp;lt;?= $user ?&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;Vous avez &amp;lt;?= count($messages) ?&amp;gt; messages en attente&amp;lt;/span&amp;gt;
    &amp;lt;?php foreach ($messages as $message): ?&amp;gt;
        &amp;lt;p&amp;gt;&amp;lt;?= $message ?&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;?php endforeach; ?&amp;gt;
&amp;lt;?php endif; ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plus le code HTML devient long, plus il devient difficile de savoir quel bloc PHP est fermé par la ligne &lt;code&gt;&amp;lt;?php } ?&amp;gt;&lt;/code&gt;. La syntaxe alternative permet d&amp;rsquo;utiliser des structures de contrôles avec la même sémantique (et aussi la même indentation) que le code HTML. Tout comme l&amp;rsquo;affichage abrégé, elle est surtout utile dans les pages qui mélangent HTML et PHP.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Le modèle MVC</title>
      <link>http://prof.bpesquet.fr/cours/modele-mvc</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/modele-mvc</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Présentation&lt;/h1&gt;

&lt;p&gt;Le modèle MVC décrit une manière d&amp;rsquo;architecturer une application informatique en la décomposant en trois sous-parties :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la partie &lt;strong&gt;Modèle&lt;/strong&gt; ;&lt;/li&gt;
&lt;li&gt;la partie &lt;strong&gt;Vue&lt;/strong&gt; ;&lt;/li&gt;
&lt;li&gt;la partie &lt;strong&gt;Contrôleur&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ce modèle de conception (&lt;em&gt;design pattern&lt;/em&gt;) a été imaginé à la fin des années 1970 pour le langage Smalltalk afin de bien séparer le code de l&amp;rsquo;interface graphique de la logique applicative. Il est utilisé dans de très nombreux langages : bibliothèques Swing et Model 2 (JSP) de Java, frameworks PHP, ASP.NET MVC, etc.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Rôles des composants&lt;/h1&gt;

&lt;p&gt;La partie &lt;strong&gt;Modèle&lt;/strong&gt; d&amp;rsquo;une architecture MVC encapsule la logique métier (&lt;em&gt;business logic&lt;/em&gt;) ainsi que l&amp;rsquo;accès aux données. Il peut s&amp;rsquo;agir d&amp;rsquo;un ensemble de fonctions (Modèle procédural) ou de classes (Modèle orienté objet).&lt;/p&gt;

&lt;p&gt;La partie &lt;strong&gt;Vue&lt;/strong&gt; s&amp;rsquo;occupe des interactions avec l&amp;rsquo;utilisateur : présentation, saisie et validation des données.&lt;/p&gt;

&lt;p&gt;La partie &lt;strong&gt;Contrôleur&lt;/strong&gt; gère la dynamique de l&amp;rsquo;application. Elle fait le lien entre l&amp;rsquo;utilisateur et le reste de l&amp;rsquo;application.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Interactions entre les composants&lt;/h1&gt;

&lt;p&gt;Le diagramme ci-dessous (extrait de la documentation du framework &lt;a href=&#34;http://symfony.com/&#34;&gt;Symfony&lt;/a&gt;) résume les relations entre les composants d&amp;rsquo;une architecture MVC.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/mvc_symfony2.png&#34; class=&#34;content centered bordered&#34; alt=&#34;mvc_symfony2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La demande de l&amp;rsquo;utilisateur (exemple : requête HTTP) est reçue et interprétée par le Contrôleur. Celui-ci utilise les services du Modèle afin de préparer les données à afficher. Ensuite, le Contrôleur fournit ces données à la Vue, qui les présente à l&amp;rsquo;utilisateur (par exemple sous la forme d&amp;rsquo;une page HTML).&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;On peut trouver des variantes moins &amp;ldquo;pures&amp;rdquo; de cette architecture dans lesquelles la Vue interagit directement avec le Modèle afin de récupérer les données dont elle a besoin.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Avantages et inconvénients&lt;/h1&gt;

&lt;p&gt;Le modèle MVC offre une séparation claire des responsabilités au sein d&amp;rsquo;une application, en conformité avec les principes de conception déjà étudiés : responsabilité unique, couplage faible et cohésion forte. Le prix à payer est une augmentation de la complexité de l&amp;rsquo;architecture.&lt;/p&gt;

&lt;p&gt;Dans le cas d&amp;rsquo;une application Web, l&amp;rsquo;utilisation du modèle MVC permet aux pages HTML (qui constituent la partie Vue) de contenir le moins possible de code serveur, étant donné que le scripting est regroupé dans les deux autres parties de l&amp;rsquo;application.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Différences avec un modèle en couches&lt;/h1&gt;

&lt;p&gt;Attention à ne pas employer le terme de &amp;ldquo;couche&amp;rdquo; à propos du modèle MVC. Dans une architecture en couches, chaque couche ne peut communiquer qu&amp;rsquo;avec les couches adjacentes. Les parties Modèle, Vue et Contrôleur ne sont donc pas des couches.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Les systèmes d&#39;exploitation</title>
      <link>http://prof.bpesquet.fr/cours/systemes-exploitation</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/systemes-exploitation</guid>
      <description>

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Ce cours a été construit collaborativement par les étudiants de BTS SIO 1ère année, en se basant sur le cours CISCO ITE.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Définition&lt;/h1&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un système d&amp;rsquo;exploitation est un logiciel qui assure l&amp;rsquo;interface entre les applications et la machine.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/SE_couches.jpg&#34; class=&#34;content centered&#34; alt=&#34;SE_couches.jpg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Rôle&lt;/h1&gt;

&lt;p&gt;Quelles que soient la taille et la complexité de l&amp;rsquo;ordinateur et de son système d&amp;rsquo;exploitation, ce dernier remplit toujours les quatre mêmes fonctions de base :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Contrôler l&amp;rsquo;accès au matériel&lt;/li&gt;
&lt;li&gt;Gérer les fichiers et les dossiers&lt;/li&gt;
&lt;li&gt;Fournir une interface utilisateur&lt;/li&gt;
&lt;li&gt;Gérer les applications&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Fonctionnalités&lt;/h1&gt;

&lt;p&gt;Les termes suivants sont souvent utilisés pour décrire les systèmes d&amp;rsquo;exploitation :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multiutilisateur : plusieurs utilisateurs peuvent disposer d&amp;rsquo;un compte individuel, ce qui leur permet d&amp;rsquo;utiliser des programmes et des périphériques simultanément.&lt;/li&gt;
&lt;li&gt;Multitâche : l&amp;rsquo;ordinateur est capable d&amp;rsquo;exécuter plusieurs applications en même temps.&lt;/li&gt;
&lt;li&gt;Multiprocesseur : le système d&amp;rsquo;exploitation peut prendre en charge plusieurs processeurs.&lt;/li&gt;
&lt;li&gt;Multithreading : un programme peut être divisé en petites parties pouvant être chargées selon les besoins par le système d&amp;rsquo;exploitation. Le multithreading permet à différentes parties d&amp;rsquo;un programme d&amp;rsquo;être exécutées simultanément.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A un instant donné, un processeur ne peut donc effectuer qu&amp;rsquo;un traitement à la fois. Pour offrir des fonctionnalités multitâche, le système d&amp;rsquo;exploitation dispose d&amp;rsquo;un ordonnanceur qui gère l&amp;rsquo;ordre dans lequel les instructions des différents programmes sont exécutées. Des priorités peuvent être affectées à chaque tâche en fonction de leur importance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/SE_ordonnancement.jpg&#34; class=&#34;content centered&#34; alt=&#34;SE_ordonnancement.jpg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Types de systèmes d&amp;rsquo;exploitation&lt;/h1&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Systèmes d&amp;rsquo;exploitation de bureau&lt;/h2&gt;

&lt;p&gt;Un système d&amp;rsquo;exploitation de bureau est conçu pour une utilisation domestique ou dans de petites entreprises, avec un nombre limité d&amp;rsquo;utilisateurs. Un système d&amp;rsquo;exploitation de réseau est utilisé dans un environnement d&amp;rsquo;entreprise, avec de nombreux utilisateurs et de multiples besoins.&lt;/p&gt;

&lt;p&gt;Sur le marché actuel des logiciels, il existe trois grandes catégories de systèmes d&amp;rsquo;exploitation de bureau : Microsoft Windows, Apple Mac OS et &lt;a href=&#34;http://fr.wikipedia.org/wiki/Unix&#34;&gt;UNIX&lt;/a&gt;/Linux.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Systèmes d&amp;rsquo;exploitation de réseau&lt;/h2&gt;

&lt;p&gt;Les systèmes d&amp;rsquo;exploitation de réseau comportent des fonctionnalités supplémentaires visant à optimiser l&amp;rsquo;utilisation et la gestion dans des environnements réseau.&lt;/p&gt;

&lt;p&gt;Les systèmes d&amp;rsquo;exploitation de réseau offrent les fonctionnalités réseau suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Applications serveur, par exemple des bases de données partagées&lt;/li&gt;
&lt;li&gt;Stockage de données centralisé&lt;/li&gt;
&lt;li&gt;Référentiel centralisé de comptes d&amp;rsquo;utilisateurs et de ressources sur le réseau&lt;/li&gt;
&lt;li&gt;File d&amp;rsquo;attente d&amp;rsquo;impression réseau&lt;/li&gt;
&lt;li&gt;Systèmes de stockage redondants, comme la technologie RAID et les sauvegardes&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Systèmes d&amp;rsquo;exploitation pour mobiles&lt;/h2&gt;

&lt;p&gt;Les systèmes d&amp;rsquo;exploitation pour mobiles permettent de gérer les besoins spécifiiques des terminaux mobiles (ressources limitées, interface tactile, etc).&lt;/p&gt;

&lt;p&gt;Le marché actuel des systèmes d&amp;rsquo;exploitation pour mobiles se partage entre iOS (Apple), Android, Windows Phone et Blackberry.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Architecture&lt;/h1&gt;

&lt;p&gt;La façon dont le processeur traite les informations peut affecter les performances du système d&amp;rsquo;exploitation. Deux architectures courantes sont utilisées pour traiter les données :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;x86 : architecture CISC 32 bits courante d&amp;rsquo;Intel adoptée par AMD et quelques autres fabricants de processeurs. Les processeurs x86 utilisent moins de registres que les processeurs x64. Les registres sont des zones de stockage utilisées par le processeur lors de l&amp;rsquo;exécution de calculs. Les processeurs x86 sont compatibles avec les systèmes d&amp;rsquo;exploitation 32 bits.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;x64 : architecture ajoutant des registres supplémentaires pour les instructions utilisant un espace d&amp;rsquo;adressage 64 bits. Ces registres supplémentaires permettent aux processeurs x64 de traiter les instructions plus rapidement que des processeurs x86. Les processeurs x64 sont rétrocompatibles avec les processeurs x86. Ils sont également compatibles avec les systèmes d&amp;rsquo;exploitation 32 bits et 64 bits.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Licence et prix&lt;/h1&gt;

&lt;p&gt;Certains systèmes d&amp;rsquo;exploitation sont libres et souvent gratuits (exemple : GNU/Linux). D&amp;rsquo;autres sont gratuis sans être libres (exemple : iOS). Enfin, certains systèmes sont payants (exemple : Windows). Le prix augmente avec les fonctionnalités réalisées : un système de réseau sera plus cher qu&amp;rsquo;un système de bureau.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Installation&lt;/h1&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Vérification de la configuration&lt;/h2&gt;

&lt;p&gt;Avant d&amp;rsquo;installer un système d&amp;rsquo;exploitation, il faut vérifier que la machine cible supporte ce système :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Architecture du processeur&lt;/li&gt;
&lt;li&gt;Quantité de RAM&lt;/li&gt;
&lt;li&gt;Compatibilité avec le matériel&lt;/li&gt;
&lt;li&gt;Espace de stockage&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Partitionnement du disque&lt;/h2&gt;

&lt;p&gt;Un disque dur est divisé en zones spécifiques appelées partitions. Une partition est une unité de stockage logique, qui peut être formatée pour stocker des informations telles que des fichiers de données ou des applications. Pendant la phase d&amp;rsquo;installation, la plupart des systèmes d&amp;rsquo;exploitation partitionnent et formatent automatiquement l&amp;rsquo;espace disque.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;installation propre d&amp;rsquo;un système d&amp;rsquo;exploitation se déroule comme si le disque dur était neuf. Aucune information présente sur le disque dur n&amp;rsquo;est conservée. La première étape de la procédure d&amp;rsquo;installation consiste à partitionner et à formater le disque dur. Cette procédure prépare le disque à accepter le nouveau système de fichiers. Le système de fichiers fournit la structure des répertoires qui organise le système d&amp;rsquo;exploitation, les applications, la configuration et les fichiers de données de l&amp;rsquo;utilisateur.&lt;/p&gt;

&lt;p&gt;Les systèmes d&amp;rsquo;exploitation Windows utilisent les systèmes de fichiers FAT32 et NTFS (New Technology File System).&lt;/p&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Multiboot&lt;/h2&gt;

&lt;p&gt;Vous pouvez faire cohabiter plusieurs systèmes d&amp;rsquo;exploitation sur un seul ordinateur. Certaines applications exigent la version la plus récente d&amp;rsquo;un système d&amp;rsquo;exploitation, alors que d&amp;rsquo;autres ont besoin d&amp;rsquo;une version antérieure. Le double démarrage permet de disposer de plusieurs systèmes d&amp;rsquo;exploitation sur un ordinateur.&lt;/p&gt;

&lt;h1 id=&#34;toc_13&#34;&gt;Administration&lt;/h1&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Gestion des processus&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un processus est l&amp;rsquo;entité qui représente l&amp;rsquo;exécution d&amp;rsquo;un programme sur un ordinateur, un ensemble d&amp;rsquo;instructions exécuté par l&amp;rsquo;utilisateur, un programme ou le système d&amp;rsquo;exploitation. Son état évolue au cours du temps : il a un début, un déroulement et une fin.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Sous Windows, le gestionnaire de tâches permet d&amp;rsquo;observer les processus en cours d&amp;rsquo;exécution.&lt;/p&gt;

&lt;h2 id=&#34;toc_15&#34;&gt;Gestion des services&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un service est un type d&amp;rsquo;application qui s&amp;rsquo;exécute en tâche de fond pour effectuer une tâche précise ou pour attendre une requête.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt; 

&lt;p&gt;Sous Windows, le gestionnaire de tâches permet de démarrer ou d&amp;rsquo;arrêter les services installés sur le système.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Les variables</title>
      <link>http://prof.bpesquet.fr/cours/variables</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/variables</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est de comprendre le rôle joué par les variables dans un programme.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Le programme d&amp;rsquo;exemple&lt;/h1&gt;

&lt;p&gt;Nous allons débuter notre apprentissage de la programmation en étudiant un exemple très simple : un programme C# qui permet de calculer un prix TTC à partir d&amp;rsquo;un prix hors taxes (toujours le même). Voici son code source.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Définition du montant hors taxes
double montantHT = 100;

// Définition du taux de TVA à 20,6%
double tauxTVA = 0.206;

// Calcul du montant de la TVA
double montantTVA = montantHT * tauxTVA;

// Calcul du montant T.T.C.
double montantTTC = montantHT + montantTVA;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On observe que ce code source se compose d&amp;rsquo;un certain nombre de &lt;strong&gt;lignes de code&lt;/strong&gt; qui se terminent toutes par le caractère &lt;code&gt;;&lt;/code&gt; : c&amp;rsquo;est une obligation en C#. Certaines lignes commencent par les caractères &lt;code&gt;//&lt;/code&gt; : ce sont des &lt;strong&gt;commentaires&lt;/strong&gt;, qui ne seront pas exécutées et permettent de documenter le code source.&lt;/p&gt;

&lt;p&gt;Tentons maintenant de comprendre le fonctionnement de ce programme.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;La notion de variable&lt;/h1&gt;

&lt;p&gt;Pour effectuer son travail, notre programme a besoin de mémoriser des informations, par exemple le montant hors taxes ou encore le taux de TVA en vigueur. Pour cela, il utilise des &lt;strong&gt;variables&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Une &lt;strong&gt;variable&lt;/strong&gt; est une zone de stockage d&amp;rsquo;informations, une sorte de &amp;ldquo;boîte&amp;rdquo; servant à ranger des choses.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Un programme emploie des variables afin de pouvoir mémoriser des informations qu&amp;rsquo;il utilisera plus tard. Au niveau de l&amp;rsquo;ordinateur, déclarer une variable déclenche la réservation d&amp;rsquo;une zone de la mémoire attribuée à cette variable. Le programme (ou l&amp;rsquo;algorithme) pourra ensuite lire ou écrire des données dans cette zone mémoire en manipulant la variable.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Déclaration d&amp;rsquo;une variable&lt;/h2&gt;

&lt;p&gt;Avant de pouvoir utiliser une variable pour stocker une information, le programme doit au préalable la créer. Cette opération s&amp;rsquo;appelle la &lt;strong&gt;déclaration&lt;/strong&gt; de la variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double tauxTVA;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En C#, la déclaration d&amp;rsquo;une variable s&amp;rsquo;effectue en choisissant :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;son &lt;strong&gt;nom&lt;/strong&gt;, qui permet de la repérer et de l&amp;rsquo;utiliser. Ici, la variable se nomme &lt;code&gt;tauxTVA&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;son &lt;strong&gt;type&lt;/strong&gt;, qui permet de définir quelles données la variable peut contenir. Ici, le type donné à la variable est &lt;code&gt;double&lt;/code&gt;, qui correspond à un nombre réel.&lt;/li&gt;
&lt;li&gt;éventuellement sa &lt;strong&gt;valeur&lt;/strong&gt;, qui correspond à l&amp;rsquo;information stockée dans la variable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lorsque le programme est exécuté, la déclaration d&amp;rsquo;une variable se traduit par la réservation d&amp;rsquo;une petite partie de la mémoire de la machine. Cette zone sera dédiée au stockage de la valeur de la variable.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Affectation d&amp;rsquo;une valeur à une variable&lt;/h2&gt;

&lt;p&gt;Une fois la variable déclarée, il est possible de lire ou d&amp;rsquo;écrire dans l&amp;rsquo;espace mémoire associé. Pour donner une nouvelle valeur à une variable, on utilise dans la plupart des langages le symbole &lt;code&gt;=&lt;/code&gt;, appelé &lt;strong&gt;opérateur d&amp;rsquo;affectation&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double tauxTVA;
tauxTVA = 0.206;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Après l&amp;rsquo;exécution de la ligne &lt;code&gt;tauxTVA = 0.206&lt;/code&gt;, la zone mémoire identifiée par &lt;em&gt;tauxTVA&lt;/em&gt; contient la valeur &lt;code&gt;0,206&lt;/code&gt;. Afin de gagner en concision, on combine souvent déclaration et affectation d&amp;rsquo;une valeur initiale sur la même ligne.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double tauxTVA = 0.206;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Dans d&amp;rsquo;autres langages comme Python ou PHP, la déclaration d&amp;rsquo;une variable se fait sans préciser son type, qui est déduit implicitement de la valeur qui lui est affectée.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Caractéristiques des variables&lt;/h1&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Nom d&amp;rsquo;une variable&lt;/h2&gt;

&lt;p&gt;Le &lt;strong&gt;nom&lt;/strong&gt; d&amp;rsquo;une variable permet de l&amp;rsquo;identifier. Il peut comporter des lettres, des chiffres, ainsi que le caractère &lt;code&gt;_&lt;/code&gt; (&lt;em&gt;underscore&lt;/em&gt;). On ne peut pas utiliser pour nommer une variable l&amp;rsquo;un des mots-clés du langage (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, etc).&lt;/p&gt;

&lt;p&gt;Afin d&amp;rsquo;améliorer la lisibilité des programmes, il est conseillé de respecter certaines règles lors du choix des noms des variables. L&amp;rsquo;une des conventions de nommage les plus employées est la convention &lt;a href=&#34;http://fr.wikipedia.org/wiki/CamelCase&#34;&gt;camelCase&lt;/a&gt;, que nous utiliserons dans la suite de ce cours.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Type d&amp;rsquo;une variable&lt;/h2&gt;

&lt;p&gt;Dans le monde réel, on n&amp;rsquo;imagine pas ranger son marteau au même endroit que ses bagues, ou que ses chaussures de football. Donner un &lt;strong&gt;type&lt;/strong&gt; à une variable revient à préciser si une boîte doit contenir des bijoux, des outils ou plutôt des chaussures.&lt;/p&gt;

&lt;p&gt;Les types utilisables dépendent du langage de programmation employé. A chaque type correspond un certain espace réservé en mémoire. Globalement, plus la plage de valeurs d&amp;rsquo;un type est grande, plus l&amp;rsquo;espace réservé sera important.&lt;/p&gt;

&lt;p&gt;Voici un bref extrait des types utilisables dans le langage C#.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type C#&lt;/th&gt;
&lt;th&gt;Traduction&lt;/th&gt;
&lt;th&gt;Signification&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Entier&lt;/td&gt;
&lt;td&gt;Un nombre entier (sans virgule)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Réel&lt;/td&gt;
&lt;td&gt;Un nombre réel (avec virgule)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Chaîne de caractères&lt;/td&gt;
&lt;td&gt;Zéro, un ou plusieurs caractères alphanumériques (lettres et/ou chiffres)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Booléen&lt;/td&gt;
&lt;td&gt;Vrai ou Faux (&lt;code&gt;true&lt;/code&gt; ou &lt;code&gt;false&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Voici d&amp;rsquo;autres exemples de déclarations de variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int x = 1;
string message = &amp;quot;Bonjour&amp;quot;;
double pi;
bool valide = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Donner une type à une variable permet de &lt;strong&gt;restreindre&lt;/strong&gt; la plage de ses valeurs possibles. Par exemple, une variable de type entier ne pourra stocker que des valeurs entières. Une tentative pour y affecter une valeur autre qu&amp;rsquo;un entier provoquera une erreur.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int nb = 0;
nb = 1;        // OK : 1 est un entier
nb = 3.14;     // erreur : 3,14 est un flottant
nb = &amp;quot;Hello&amp;quot;;  // erreur : &amp;quot;Hello&amp;quot; est une chaîne de caractères
nb = true;     // erreur : true est un booléen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le typage des variables offre deux avantages :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;améliorer la lisibilité du programme (ou de l&amp;rsquo;algorithme).&lt;/li&gt;
&lt;li&gt;prévenir les erreurs de type (interdire de ranger une perceuse dans une boîte à bijoux).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Valeur d&amp;rsquo;une variable&lt;/h2&gt;

&lt;p&gt;La &lt;strong&gt;valeur&lt;/strong&gt; d&amp;rsquo;une variable représente le contenu de la zone mémoire associée à la variable. En C#, la valeur d&amp;rsquo;une variable doit toujours être compatible avec son type.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Variables et calculs&lt;/h2&gt;

&lt;p&gt;Nous avons vu que l&amp;rsquo;on peut affecter une nouvelle valeur à une variable avec l&amp;rsquo;opérateur &lt;code&gt;=&lt;/code&gt;. Il est possible d&amp;rsquo;employer des variables dans le calcul de cette nouvelle valeur.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
double montantTVA = montantHT * tauxTVA;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ici, &lt;code&gt;montantHT * tauxTVA&lt;/code&gt; est ce qu&amp;rsquo;on appelle une &lt;strong&gt;expression&lt;/strong&gt;. Lors de l&amp;rsquo;exécution du programme, l&amp;rsquo;expression est évaluée pour donner un résultat que l&amp;rsquo;on peut affecter à une autre variable. Pendant ce processus, les variables présentes dans l&amp;rsquo;expression sont automatiquement remplacées par leurs valeurs. Le type du résultat dépend de ceux des variables et de l&amp;rsquo;opérateur utilisés dans l&amp;rsquo;expression.&lt;/p&gt;

&lt;p&gt;Quand leur type le permet, il est possible d&amp;rsquo;effectuer des calculs arithmétiques sur des variables. Avec des variables de type entier ou réel, on peut utiliser les opérateurs arithmétiques habituels.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opérateur&lt;/th&gt;
&lt;th&gt;Signification&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Addition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Soustraction&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Multiplication&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Division&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A présent, nous pouvons prévoir le résultat de l&amp;rsquo;exécution de notre exemple initial.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Définition du montant hors taxes
double montantHT = 100;

// Définition du taux de TVA à 20,6%
double tauxTVA = 0.206;

// Calcul du montant de la TVA
double montantTVA = montantHT * tauxTVA;

// Calcul du montant T.T.C.
double montantTTC = montantHT + montantTVA;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La variable &lt;em&gt;montantTVA&lt;/em&gt; reçoit le résultat de la multiplication de &lt;code&gt;montantHT&lt;/code&gt; par &lt;code&gt;tauxTVA&lt;/code&gt;. Sa valeur est &lt;code&gt;20,6&lt;/code&gt;. Ensuite, la variable &lt;code&gt;montantTTC&lt;/code&gt; reçoit le résultat de l&amp;rsquo;addition entre &lt;code&gt;montantHT&lt;/code&gt; et &lt;code&gt;montantTVA&lt;/code&gt;. La valeur finale de &lt;code&gt;montantTTC&lt;/code&gt; est donc &lt;code&gt;120,6&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Passage de paramètres</title>
      <link>http://prof.bpesquet.fr/cours/passage-parametres</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/passage-parametres</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est d&amp;rsquo;apprendre à échanger des données avec un sous-programme.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Introduction&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intérêt du passage de paramètres&lt;/h2&gt;

&lt;p&gt;Supposons qu&amp;rsquo;on souhaite écrire un programme qui dise bonjour à son utilisateur dans différentes langues. Une première solution consiste à écrire un sous-programme par langue.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    DireBonjour();
    SayHello();
    DecirHola();
}

static void DireBonjour()
{
    Console.WriteLine(&amp;quot;Bonjour !&amp;quot;);
}

static void SayHello()
{
    Console.WriteLine(&amp;quot;Hello !&amp;quot;);
}

static void DecirHola()
{
    Console.WriteLine(&amp;quot;Hola !&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cette solution n&amp;rsquo;est pas très satisfaisante : même s&amp;rsquo;il se limite ici à une ligne, le code d&amp;rsquo;affichage est dupliqué dans tous les sous-programmes. Il serait préférable de &lt;strong&gt;centraliser&lt;/strong&gt; cette opération dans un seul sous-programme, en faisant changer uniquement le message affiché.&lt;/p&gt;

&lt;p&gt;Jusqu&amp;rsquo;à présent, la seule solution que nous connaissons pour échanger des données entre le programme principal et le sous-programme repose sur l&amp;rsquo;utilisation de variables globales.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static string messageBonjour;

static void Main(string[] args)
{
     messageBonjour = &amp;quot;Bonjour !&amp;quot;;
     DireBonjour();
     messageBonjour = &amp;quot;Hello !&amp;quot;;
     DireBonjour();
     messageBonjour = &amp;quot;Hola !&amp;quot;;
     DireBonjour();
}

static void DireBonjour()
{
     Console.WriteLine(messageBonjour);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le code d&amp;rsquo;affichage est centralisé, ce qui est un progrès par rapport à la solution précédente. Cependant, le sous-programme &lt;code&gt;DireBonjour&lt;/code&gt; ne peut plus fonctionner si une variable globale nommée &lt;code&gt;messageBonjour&lt;/code&gt; n&amp;rsquo;est pas déclarée et affectée à la bonne valeur avant chaque appel. Cela limite la &lt;strong&gt;modularité&lt;/strong&gt; du code et la réutilisation du sous-programme dans un autre contexte.&lt;/p&gt;

&lt;p&gt;On aimerait pouvoir écrire un sous-programme qui puisse échanger des informations avec le programme appelant tout en restant indépendant. Une solution existe : le passage de paramètres.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Un premier exemple&lt;/h2&gt;

&lt;p&gt;Voici une adaptation du contexte précédent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    string messageBonjour = &amp;quot;Bonjour !&amp;quot;;
    DireBonjour(messageBonjour);

    messageBonjour = &amp;quot;Hello !&amp;quot;;
    DireBonjour(messageBonjour);

    messageBonjour = &amp;quot;Hola !&amp;quot;;
    DireBonjour(messageBonjour);
}

static void DireBonjour(string message)  // message est un paramètre de DireBonjour
{
    Console.WriteLine(message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/passage_parametre.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;passage_parametre.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La définition du sous-programme comporte de nouveaux éléments. Elle inclut à présent un &lt;strong&gt;paramètre&lt;/strong&gt; nommé &lt;code&gt;message&lt;/code&gt; dont le type est &lt;code&gt;string&lt;/code&gt;. A l&amp;rsquo;intérieur du sous-programme, &lt;code&gt;message&lt;/code&gt; est utilisée comme une variable locale classique. Mais &lt;code&gt;message&lt;/code&gt; n&amp;rsquo;est déclarée nulle part. Il s&amp;rsquo;agit d&amp;rsquo;une variable fictive appelée parfois variable formelle ou encore paramètre formel.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;On appelle &lt;strong&gt;paramètre&lt;/strong&gt; une donnée attendue par un
sous-programme qui doit lui être fournie lors de chaque appel. La liste
des paramètres d&amp;rsquo;un sous-programme est définie entre parenthèses après
le nom du sous-programme.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Au moment de l&amp;rsquo;appel du sous-programme &lt;code&gt;DireBonjour&lt;/code&gt;, le paramètre &lt;code&gt;message&lt;/code&gt; prend la valeur de la variable utilisée dans l&amp;rsquo;appel, c&amp;rsquo;est-à-dire &lt;code&gt;messageBonjour&lt;/code&gt;. Puisque la variable &lt;code&gt;messageBonjour&lt;/code&gt; est celle dont la valeur est concrètement utilisée, elle est appelée paramètre effectif du sous-programme ou encore &lt;strong&gt;argument&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;On appelle &lt;strong&gt;argument&lt;/strong&gt; la valeur fournie pour un paramètre au moment d&amp;rsquo;un appel du sous-programme.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;A présent, le sous-programme &lt;code&gt;DireBonjour&lt;/code&gt; n&amp;rsquo;est plus lié au programme appelant. On pourrait très bien le recopier tel quel dans un autre programme.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Fonctionnement du passage de paramètres&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;ajout de &lt;strong&gt;paramètres&lt;/strong&gt; à un sous-programme permet d&amp;rsquo;échanger des données avec le programme appelant, tout en maintenant le sous-programme indépendant (ce qui n&amp;rsquo;est plus le cas quand le sous-programme utilise des variables globales).&lt;/p&gt;

&lt;p&gt;Au moment de l&amp;rsquo;appel au sous-programme, la valeur des données utilisés pour l&amp;rsquo;appel, appelées &lt;strong&gt;arguments&lt;/strong&gt; (paramètres effectifs), est affectée aux &lt;strong&gt;paramètres&lt;/strong&gt; (formels) du sous-programme. A l&amp;rsquo;intérieur d&amp;rsquo;un sous-programme, un paramètre se comporte comme une variable locale.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Les paramètres et les arguments peuvent avoir des &lt;strong&gt;noms&lt;/strong&gt; différents mais doivent partager le même &lt;strong&gt;type&lt;/strong&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Possibilités d&amp;rsquo;utilisation&lt;/h2&gt;

&lt;p&gt;Un sous-programme peut comporter les mêmes éléments qu&amp;rsquo;un programme classique : tests, boucles, etc. Il peut être appelé plusieurs fois depuis le programme principal. A chaque appel, les paramètres prennent la valeur des arguments pendant l&amp;rsquo;exécution du sous-programme. Voici un nouvel exemple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
     int nb1 = 6;
     int nb2 = 4;
     AfficherMax(nb1, nb2);   // 1er appel
     AfficherMax(2, 9);       // 2ème appel
     AfficherMax(nb1, nb1);   // 3ème appel
}

static void AfficherMax(int x, int y)
{
    if (x &amp;gt; y)
    {
        Console.WriteLine(x + &amp;quot; est plus grand que &amp;quot; + y);
    }
    else
    {
        if (x &amp;lt; y)
            Console.WriteLine(x + &amp;quot; est plus petit que &amp;quot; + y);
        else
            Console.WriteLine(x + &amp;quot; et &amp;quot; + y + &amp;quot; sont égaux&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/afficher_max.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;afficher_max.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le tableau ci-dessous rassemble les informations sur les différents appels du sous-programme.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Appel&lt;/th&gt;
&lt;th&gt;Valeur de x&lt;/th&gt;
&lt;th&gt;Valeur de y&lt;/th&gt;
&lt;th&gt;Message affiché&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1er appel&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;6 est plus grand que 4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2ème appel&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;2 est plus petit que 9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3ème appel&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;6 et 6 sont égaux&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Aspects avancés&lt;/h1&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Mode de passage des paramètres&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;exemple suivant va nous permettre de découvrir un aspect délicat du passage de paramètres.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    int x = 6;
    AugmenterDeUn(x);
    Console.WriteLine(&amp;quot;Programme principal : x vaut &amp;quot; + x);
}

static void AugmenterDeUn(int y)
{
    y = y + 1;
    Console.WriteLine(&amp;quot;Sous-programme : y vaut &amp;quot; + y);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/augmenter_de_un.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;augmenter_de_un.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pour comprendre ce résultat, il faut savoir que lorsqu&amp;rsquo;une variable est passée en paramètre à un sous-programme, la valeur de l&amp;rsquo;argument est &lt;strong&gt;copiée&lt;/strong&gt; dans un nouvel emplacement mémoire correspondant au paramètre. La même valeur (ici &lt;em&gt;6&lt;/em&gt;) est donc stockée à &lt;em&gt;deux&lt;/em&gt; emplacements mémoire différents, celui de l&amp;rsquo;argument &lt;em&gt;x&lt;/em&gt; et celui du paramètre &lt;em&gt;y&lt;/em&gt;. Toute modification du paramètre dans le sous-programme n&amp;rsquo;a aucun impact sur la valeur de l&amp;rsquo;argument dans le programme principal.&lt;/p&gt;

&lt;p&gt;On appelle &lt;strong&gt;passage par valeur&lt;/strong&gt; ce mode de passage des paramètres. C&amp;rsquo;est le mode par défaut en C#, ainsi qu&amp;rsquo;en Java.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Nommage des paramètres&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;exemple ci-dessous va illustrer une subtilité liée au nommage des paramètres d&amp;rsquo;un sous-programme.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    int x = 6;
    AugmenterD Un(x);
    Console.WriteLine(&amp;quot;Programme principal : x vaut &amp;quot; + x);
}

static void AugmenterDeUn(int x)
{
    x = x + 1;
    Console.WriteLine(&amp;quot;Sous-programme : x vaut &amp;quot; + x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Il s&amp;rsquo;agit du même exemple que précédemment, à une différence près : le paramètre du sous-programme a été renommé et porte le même nom que l&amp;rsquo;argument du programme principal.&lt;/p&gt;

&lt;p&gt;Ce programme est compilable sans erreur et son exécution donne le résultat ci-dessous.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/nommage_parametre.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;nommage_parametre.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ce résultat s&amp;rsquo;explique exactement de la même manière que le précédent : au moment de l&amp;rsquo;appel, la valeur de l&amp;rsquo;argument est copiée dans la zone mémoire du paramètre. La modification au niveau du sous-programme n&amp;rsquo;a donc pas d&amp;rsquo;effet sur la variable du programme principal. La seule différence concerne ici le programmeur, et non la machine : paramètre et argument portent le même nom &lt;em&gt;x&lt;/em&gt;, ce qui ne provoque pas d&amp;rsquo;erreur mais affecte la lisibilité du code, surtout pour un programmeur débutant.&lt;/p&gt;

&lt;div class=&#34;alert alert-success&#34;&gt;
    &lt;strong&gt;Conseil&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;En phase d&amp;rsquo;apprentissage, il est conseillé de donner aux arguments des noms différents de ceux des paramètres.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Programmation modulaire</title>
      <link>http://prof.bpesquet.fr/cours/programmation-modulaire</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/programmation-modulaire</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est d&amp;rsquo;apprendre à écrire des programmes en les décomposant en différentes sous-parties.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Introduction&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Limites des programmes classiques&lt;/h2&gt;

&lt;p&gt;Jusqu&amp;rsquo;à présent, nos programmes ont toujours été écrits d&amp;rsquo;un bloc. Cependant, lorsque la taille d&amp;rsquo;un programme augmente, on se rend souvent compte que certaines instructions ou groupes d&amp;rsquo;instructions ont tendance à se répéter.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Minimiser la duplication de code&lt;/strong&gt; est l&amp;rsquo;un des objectifs essentiels du (bon) programmeur. En effet, dupliquer du code produit les effets négatifs suivants :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la taille du programme (nombre de lignes d&amp;rsquo;instructions) augmente,&lt;/li&gt;
&lt;li&gt;sa lisibilité diminue,&lt;/li&gt;
&lt;li&gt;les modifications du programme sont plus longues et plus complexes (risque d&amp;rsquo;oubli).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour éviter cela, on aimerait pouvoir &amp;ldquo;factoriser&amp;rdquo; certaines parties du programme, c&amp;rsquo;est-à-dire les définir à un seul endroit puis y faire appel autant de fois que nécessaire. Ces parties sont appelées des &lt;strong&gt;sous-programmes&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Un premier sous-programme&lt;/h2&gt;

&lt;p&gt;Voici un exemple très simple utilisant un sous-programme.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Programme principal
static void Main(string[] args)
{
    DireBonjour();
    DireBonjour();
    DireBonjour();
}

// Sous-programme
static void DireBonjour()
{
    Console.WriteLine(&amp;quot;Bonjour !&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/sous_programme.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;sous_programme.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le sous-programme défini dans cet exemple se nomme &lt;code&gt;DireBonjour&lt;/code&gt;. Il est délimité par une paire d&amp;rsquo;accolades ouvrantes et fermantes.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Le bloc &lt;code&gt;static void Main(...)&lt;/code&gt; constitue le point d&amp;rsquo;entrée dans le programme, par où commence son exécution. On l&amp;rsquo;appelle également &lt;strong&gt;programme principal&lt;/strong&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Dans cet exemple, le sous-programme est appelé trois fois depuis le programme principal. Chaque appel déclenche l&amp;rsquo;affichage du message &amp;ldquo;Bonjour !&amp;rdquo;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un &lt;strong&gt;sous-programme&lt;/strong&gt; est un petit programme inséré dans un programme général. Un sous-programme possède un nom et est délimité par des accolades.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Déroulement de l&amp;rsquo;exécution&lt;/h2&gt;

&lt;p&gt;Jusqu&amp;rsquo;à présent, les programmes que nous avons étudiés s&amp;rsquo;exécutaient de manière linéaire, du début à la fin, même en cas de présence de boucles. L&amp;rsquo;utilisation de sous-programmes va compliquer les choses.&lt;/p&gt;

&lt;p&gt;Lorsque qu&amp;rsquo;on a besoin d&amp;rsquo;utiliser la fonctionnalité d&amp;rsquo;un sous-programme, on effectue un &lt;strong&gt;appel&lt;/strong&gt; à celui-ci. Cet appel provoque un &amp;ldquo;branchement&amp;rdquo; vers le sous-programme, qui s&amp;rsquo;exécute. Une fois l&amp;rsquo;exécution du sous-programme terminé, le contrôle revient au niveau de l&amp;rsquo;appelant et l&amp;rsquo;exécution se poursuit. Ce fonctionnement est illustré par le schéma ci-après.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/appel_sous_prog.jpg&#34; class=&#34;content centered&#34; alt=&#34;appel_sous_prog.jpg&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Sans les nommer ainsi, nous avons déjà utilisé plusieurs &amp;ldquo;sous-programmes&amp;rdquo; fournis par l&amp;rsquo;environnement C# comme &lt;code&gt;Console.WriteLine&lt;/code&gt; ou encore &lt;code&gt;Convert.ToDouble&lt;/code&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
    

&lt;h2 id=&#34;toc_4&#34;&gt;Intérêt des sous-programmes&lt;/h2&gt;

&lt;p&gt;Lorsqu&amp;rsquo;on cherche à résoudre un problème complexe, il est généralement efficace de le &lt;strong&gt;décomposer&lt;/strong&gt; en sous-problèmes plus simples. Les sous-programmes permettent d&amp;rsquo;appliquer ce principe à la réalisation de logiciels : on va décomposer le programme en écrivant plusieurs sous-programmes plus ou moins autonomes, chacun dédié à une tâche particulière. Le programme principal fera appel aux sous-programmes au fur et à mesure de son exécution.&lt;/p&gt;

&lt;p&gt;Ainsi écrit sous la forme d&amp;rsquo;une combinaison de sous-programmes, notre programme final sera plus &lt;strong&gt;lisible&lt;/strong&gt; et plus facile à &lt;strong&gt;maintenir&lt;/strong&gt; et à &lt;strong&gt;faire évoluer&lt;/strong&gt;. De plus, il sera parfois possible de &lt;strong&gt;réutiliser&lt;/strong&gt; certains sous-programmes dans d&amp;rsquo;autre contextes.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Ecriture de sous-programmes&lt;/h1&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Valeur de retour&lt;/h2&gt;

&lt;p&gt;Le sous-programme que nous avons étudié ne renvoit aucune valeur au programme principal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...

// Sous-programme
static void DireBonjour()
{
    Console.WriteLine(&amp;quot;Bonjour !&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;absence de valeur de retour est indiquée en C# par le mot-clé &lt;code&gt;void&lt;/code&gt; avant le nom du sous-programme. Un sous-programme qui ne renvoie pas de valeur est appelé une &lt;strong&gt;procédure&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En fonction des besoins, il est également possible d&amp;rsquo;écrire un sous-programme qui renvoie une valeur de retour, comme dans l&amp;rsquo;exemple ci-dessous.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    string messageRecu = DireBonjour();
    Console.WriteLine(&amp;quot;Le sous-programme vous dit : &amp;quot; + messageRecu);
}

static string DireBonjour()
{
    return &amp;quot;Bonjour !&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/sous_prog_fonction.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;sous_prog_fonction.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Par rapport à le version précédente du sous-programme &lt;code&gt;DireBonjour&lt;/code&gt;, on observe ici la présence d&amp;rsquo;un &lt;strong&gt;type de retour&lt;/strong&gt; (&lt;code&gt;string&lt;/code&gt;) et le renvoi d&amp;rsquo;une valeur en fin de sous-programme (&amp;ldquo;Bonjour !&amp;rdquo;) grâce au mot-clé &lt;code&gt;return&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Quand on crée un sous-programme qui renvoie une valeur de retour, on
doit :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;préciser quel est le type de la valeur renvoyée par le sous-programme.&lt;/li&gt;
&lt;li&gt;définir quelle est la valeur renvoyée en utilisant le mot-clé &lt;code&gt;return&lt;/code&gt; à la fin du sous-programme.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un sous-programme qui renvoie une valeur est appelé une &lt;strong&gt;fonction&lt;/strong&gt;. L&amp;rsquo;appel d&amp;rsquo;un sous-programme renvoyant une valeur retourne toujours un résultat, qui peut être récupéré et utilisé ensuite par le programme appelant.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Variables locales&lt;/h2&gt;

&lt;p&gt;Il est possible de déclarer des variables dans un sous-programme de la même manière que dans le programme principal. L&amp;rsquo;utilisation de variables dans un sous-programme permet d&amp;rsquo;améliorer sa lisibilité et de réaliser des opérations plus complexes, comme des calculs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    string messageRecu = DireBonjour();
    Console.WriteLine(&amp;quot;Le sous-programme vous dit : &amp;quot; + messageRecu);
}

static string DireBonjour()
{
    string message = &amp;quot;Bonjour !&amp;quot;;
    return message;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le sous-programme de l&amp;rsquo;exemple ci-dessus comporte une variable &lt;code&gt;message&lt;/code&gt; de type &lt;code&gt;string&lt;/code&gt;. Son résultat d&amp;rsquo;exécution est identique à celui de l&amp;rsquo;exemple précédent.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Une variable déclarée dans un sous-programme est appelée &lt;strong&gt;variable locale&lt;/strong&gt; à ce sous-programme.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Voici un autre exemple de sous-programme qui fait saisir un nombre entier et le renvoie au programme appelant.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    int nombreSaisi = SaisirEntier();
    Console.WriteLine(&amp;quot;Le nombre saisi est &amp;quot; + nombreSaisi);
}

static int SaisirEntier()
{
    Console.Write(&amp;quot;Entrez un nombre entier : &amp;quot;);
    string saisie = Console.ReadLine();
    int nombre = Convert.ToInt32(saisie);
    return nombre;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/saisir_entier.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;saisir_entier.jpg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Portée des variables locales&lt;/h2&gt;

&lt;p&gt;Nous avons rencontré la notion de &lt;strong&gt;portée&lt;/strong&gt; d&amp;rsquo;une variable dans le chapitre précédent (TODO). Cette notion prend de l&amp;rsquo;importance quand on pratique la programmation modulaire. Voici l&amp;rsquo;un des exemples précédents, légèrement modifié.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
     string messageRecu = DireBonjour();
     Console.WriteLine(&amp;quot;Le sous-programme vous dit : &amp;quot; + messageRecu);
     Console.WriteLine(&amp;quot;Mais peut-il vous dire &amp;quot; + message + &amp;quot; ?&amp;quot;);
}

static string DireBonjour()
{
     string message = &amp;quot;Bonjour !&amp;quot;;
     return message;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Une tentative d&amp;rsquo;exécution se solde par un message d&amp;rsquo;erreur provenant du compilateur.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/portee_variable_locale.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;portee_variable_locale.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cette erreur prouve le fait que la variable &lt;em&gt;message&lt;/em&gt;, locale au sous-programme &lt;code&gt;DireBonjour&lt;/code&gt;, n&amp;rsquo;est pas utilisable en-dehors de celui-ci.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La portée d&amp;rsquo;une variable locale se limite au sous-programme dans lequel elle est déclarée.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Ne pas pouvoir utiliser de variables locales en dehors des sous-programmes où elles sont définies peut sembler une limitation. C&amp;rsquo;est au contraire un grand avantage : chaque sous-programme peut déclarer ses propres variables sans se préoccuper des variables locales définies ailleurs.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Variables globales&lt;/h2&gt;

&lt;p&gt;Il existe des situations où on souhaiterait que des variables soient utilisables depuis n&amp;rsquo;importe quel endroit du programme.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void Main(string[] args)
{
    int a = 5;
    int b = 10;
    Console.WriteLine(&amp;quot;Avant l&#39;échange, a=&amp;quot; + &amp;quot; et b=&amp;quot; + b);
    Echanger();
    Console.WriteLine(&amp;quot;Après l&#39;échange, a=&amp;quot; + &amp;quot; et b=&amp;quot; + b);
}

static void Echanger()
{
    int temp = b;
    b = a;
    a = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ce programme ne peut être exécuté : les variables &lt;code&gt;a&lt;/code&gt; et &lt;code&gt;b&lt;/code&gt; sont déclarées dans le programme principal et ne sont pas visibles depuis le sous-programme &lt;em&gt;Echanger&lt;/em&gt;. Ces variables sont locales au programme principal.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/erreur_variable_locale.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;erreur_variable_locale.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pour pouvoir utiliser &lt;code&gt;a&lt;/code&gt; et &lt;code&gt;b&lt;/code&gt; partout, il faut les déclarer en dehors du programme principal et de tout sous-programme. On appelle ces variables des &lt;strong&gt;variables globales&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Déclaration des variables globales
static int a;
static int b;

static void Main(string[] args)
{
    a = 5;
    b = 10;
    Console.WriteLine(&amp;quot;Avant l&#39;échange, a=&amp;quot; + a + &amp;quot; et b=&amp;quot; + b);
    Echanger();
    Console.WriteLine(&amp;quot;Après l&#39;échange, a=&amp;quot; + a + &amp;quot; et b=&amp;quot; + b);
}

static void Echanger()
{
    int temp = b;
    b = a;
    a = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/variable_globale.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;variable_globale.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Quand on programme de manière modulaire, il faut être attentif à l&amp;rsquo;endroit où on déclare les variables. Les variables globales semblent plus pratiques à utiliser puisqu&amp;rsquo;elles sont visibles depuis n&amp;rsquo;importe quel endroit du programme.&lt;/p&gt;

&lt;p&gt;Cependant, elles présentent plusieurs défauts. Un sous-programme qui utilise des variables globales est plus difficile à réutiliser dans un autre contexte. De plus, une variable globale peut être utilisée depuis n&amp;rsquo;importe quel endroit du programme, ce qui augmente le risque de modification accidentelle.&lt;/p&gt;

&lt;div class=&#34;alert alert-success&#34;&gt;
    &lt;strong&gt;Conseil&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Il est conseillé de &lt;strong&gt;minimiser&lt;/strong&gt; le nombre de variables globales, voire de s&amp;rsquo;en passer complètement.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Programmer avec des variables</title>
      <link>http://prof.bpesquet.fr/cours/programmer-variables</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/programmer-variables</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est de découvrir comment utiliser des variables dans un programme.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Le programme d&amp;rsquo;exemple&lt;/h1&gt;

&lt;p&gt;Le programme d&amp;rsquo;exemple du chapitre précédent était simpliste. Enrichissons-le en permettant à l&amp;rsquo;utilisateur de saisir le montant hors taxes et en lui affichant le résultat du calcul.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string msg = &amp;quot;Bienvenue dans l&#39;application TVA !&amp;quot;;
Console.WriteLine(msg);

// Saisie et conversion du montant hors taxes
Console.Write(&amp;quot;Entrez un montant HT : &amp;quot;);
string saisie = Console.ReadLine();
double montantHT = Convert.ToDouble(saisie);

// Définition du taux de TVA à 20,6%
double tauxTVA = 0.206;

// Calcul du montant T.T.C.
double montantTTC = montantHT * (1 + tauxTVA);

// Affichage du montant converti
string sortie = &amp;quot;Le montant TTC est de &amp;quot; + montantTTC;
Console.WriteLine(sortie);

Console.WriteLine(&amp;quot;Merci d&#39;avoir utilisé l&#39;application. Au revoir !&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voici le résultat de son exécution sous la forme d&amp;rsquo;une application console.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/calcul_tva.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;calcul_tva.jpg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Chaînes de caractères&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Création d&amp;rsquo;une chaîne de caractères&lt;/h2&gt;

&lt;p&gt;Une chaîne de caractères (en anglais &lt;code&gt;string&lt;/code&gt;) représente un ensemble de caractères. Un caractère correspond &lt;em&gt;grosso modo&lt;/em&gt; à ce qu&amp;rsquo;on peut obtenir en tapant sur une touche d&amp;rsquo;un clavier : une lettre, un chiffre, un espace, un signe de ponctuation, un symbole comme $ ou µ.&lt;/p&gt;

&lt;p&gt;En programmation, on matérialise le début et la fin d&amp;rsquo;une chaîne de caractères avec des &lt;strong&gt;guillemets doubles&lt;/strong&gt; (caractère &lt;code&gt;&amp;quot;&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string msg = &amp;quot;Bienvenue dans l&#39;application TVA !&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Concaténation de chaînes&lt;/h1&gt;

&lt;p&gt;Il est possible de créer une chaîne de caractères par assemblage d&amp;rsquo;autres chaînes. Cette opération s&amp;rsquo;appelle la &lt;strong&gt;concaténation&lt;/strong&gt;. En C#, elle est réalisée au moyen de l&amp;rsquo;opérateur &lt;code&gt;+&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string msg = &amp;quot;Bienvenue&amp;quot;;
msg = msg + &amp;quot; en&amp;quot;;
msg += &amp;quot; BTS SIO !&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ici, la valeur finale de la variable &lt;em&gt;msg&lt;/em&gt; sera &lt;em&gt;Bienvenue en BTS SIO !&lt;/em&gt;. L&amp;rsquo;opérateur &lt;code&gt;+=&lt;/code&gt; est un raccourci : écrire &lt;code&gt;variable += valeur&lt;/code&gt; équivaut exactement à écrire &lt;code&gt;variable = variable + valeur&lt;/code&gt;, en plus concis.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Affichage à l&amp;rsquo;écran&lt;/h1&gt;

&lt;p&gt;L&amp;rsquo;instruction C# &lt;code&gt;Console.WriteLine&lt;/code&gt; permet d&amp;rsquo;écrire à l&amp;rsquo;écran le texte qui la suit entre parenthèses.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string msg = &amp;quot;Bienvenue dans l&#39;application TVA !&amp;quot;;
Console.WriteLine(msg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le texte à afficher est fourni sous la forme d&amp;rsquo;une chaîne de caractères : soit une variable de type &lt;code&gt;string&lt;/code&gt;, soit directement un texte entre guillemets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Merci d&#39;avoir utilisé l&#39;application. Au revoir !&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Saisie d&amp;rsquo;informations&lt;/h1&gt;

&lt;p&gt;L&amp;rsquo;instruction C# &lt;code&gt;Console.ReadLine&lt;/code&gt; permet d&amp;rsquo;attendre le résultat de la saisie utilisateur au clavier. Ici, son résultat est affecté à la variable nommée &lt;code&gt;saisie&lt;/code&gt;, qui est de type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
string saisie = Console.ReadLine();
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;&lt;code&gt;Console.ReadLine&lt;/code&gt; renvoit toujours une valeur de type &lt;code&gt;string&lt;/code&gt;, même si l&amp;rsquo;utilisateur saisit une valeur compatible avec un autre type, comme un entier.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
  

&lt;h1 id=&#34;toc_6&#34;&gt;Conversion de type&lt;/h1&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Conversion explicite&lt;/h2&gt;

&lt;p&gt;Nous avons vu précédemment que des variables devaient être de type numérique pour pouvoir être utilisées dans des calculs. Cependant, l&amp;rsquo;instruction &lt;code&gt;Console.ReadLine&lt;/code&gt; renvoit toujours une chaîne de caractères (&lt;code&gt;string&lt;/code&gt;). Le langage C# permet heureusement de convertir cette chaîne en une valeur numérique.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
string saisie = Console.ReadLine();
double montantHT = Convert.ToDouble(saisie);  // conversion explicite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;instruction C# &lt;code&gt;Convert.ToDouble&lt;/code&gt; permet de passer d&amp;rsquo;une valeur de type &lt;code&gt;string&lt;/code&gt; (ici la variable &lt;code&gt;saisie&lt;/code&gt;) à un résultat de type &lt;code&gt;double&lt;/code&gt;, affecté ici à la variable &lt;code&gt;montantHT&lt;/code&gt;. Il s&amp;rsquo;agit d&amp;rsquo;une conversion de type expressément demandée par le programmeur, ou conversion &lt;strong&gt;explicite&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Conversion implicite&lt;/h1&gt;

&lt;p&gt;Dans certaines situations, le langage C# peut automatiser la conversion de type sans intervention du programmeur. On parle alors de conversion &lt;strong&gt;implicite&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
double montantTTC = montantHT * (1 + tauxTVA);
string sortie = &amp;quot;Le montant TTC est de &amp;quot; + montantTTC;  // conversion implicite
Console.WriteLine(sortie);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ici, une conversion implicite de la variable &lt;code&gt;montantTTC&lt;/code&gt; (de type &lt;code&gt;double&lt;/code&gt;) vers le type &lt;code&gt;string&lt;/code&gt; a lieu avant la concaténation. Il est même possible d&amp;rsquo;être encore plus concis.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
double montantTTC = montantHT * (1 + tauxTVA);
Console.WriteLine(&amp;quot;Le montant TTC est de &amp;quot; + montantTTC);  // conversion implicite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les principales conversions implicites concernent :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;les conversions d&amp;rsquo;un type numérique (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;) vers le type &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;les conversion d&amp;rsquo;un type numérique vers un autre type numérique capable de stocker l&amp;rsquo;information sans perte.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a = 3;
double b = a;  // OK, un réel peut stocker une valeur entière
int c = b;     // erreur : un entier ne peut pas stocker une valeur réelle
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Erreurs fréquentes&lt;/h1&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Redéclaration d&amp;rsquo;une variable&lt;/h2&gt;

&lt;p&gt;Au sein d&amp;rsquo;une même unité de code source, deux variables différentes ne peuvent pas porter le même nom. En C#, une unité de code source est la zone délimitée par une paire d&amp;rsquo;accolades ouvrantes et fermantes.&lt;/p&gt;

&lt;p&gt;Une erreur fréquente consiste à redéclarer la variable qu&amp;rsquo;on souhaite simplement réutiliser. Cela provoque une erreur, comme dans l&amp;rsquo;exemple ci-dessous.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
double montantHT = 0;
// ...
double montantHT = 150;  // Erreur : redéclaration de la variable montantHT !
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comme la plupart des langages, le C# fait la distinction entre les minuscules et les majuscules dans les noms des variables. On dit qu&amp;rsquo;il est &lt;strong&gt;sensible à la casse&lt;/strong&gt; (&lt;em&gt;case sensitive&lt;/em&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
double montantHT = 0;
// ...
double montantHt = 150;  // OK : déclaration d&#39;une nouvelle variable montantHt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Utilisation d&amp;rsquo;une variable non initialisée&lt;/h2&gt;

&lt;p&gt;Le langage C# interdit l&amp;rsquo;utilisation d&amp;rsquo;une variable tant qu&amp;rsquo;une valeur ne lui a pas été affectée.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double a;
double b = a;  // erreur : a n&#39;a pas de valeur
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Mauvaise utilisation des guillemets&lt;/h2&gt;

&lt;p&gt;Dans un programme C#, tout ce qui se trouve à l&amp;rsquo;intérieur d&amp;rsquo;une paire de guillemets est considéré comme une chaîne de caractères. Il faut donc être attentif au placement des guillemets, puisque le typage des variables interdit de leur affecter une valeur incompatible avec leur type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double val = 20.6;    // OK
double val = &amp;quot;20.6&amp;quot;;  // erreur : &amp;quot;19.6&amp;quot; est une valeur de type string

string msg = &amp;quot;3.14&amp;quot;;  // OK
string msg = 3.14;    // erreur : 3.14 est une valeur de type réel
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Confusion entre concaténation et addition&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;opérateur &lt;code&gt;+&lt;/code&gt; a un sens différent selon le type de ses arguments :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;appliqué à des entiers ou des réels, il exprime l&amp;rsquo;addition mathématique.&lt;/li&gt;
&lt;li&gt;appliqué à des chaînes de caractères, il permet de les concaténer en une seule chaîne.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int x = 421;
int y = 9;
int z = x + y;         // après l&#39;exécution, la variable z vaut 430

string a = &amp;quot;421&amp;quot;;
string b = &amp;quot;9&amp;quot;;
string c = a + b;      // après l&#39;exécution, la variable c vaut &amp;quot;4219&amp;quot;
string d = &amp;quot;a + b&amp;quot;;    // après l&#39;exécution, la variable d vaut &amp;quot;a + b&amp;quot;
string e = &amp;quot;a&amp;quot; + &amp;quot;b&amp;quot;;  // après l&#39;exécution, la variable e vaut &amp;quot;ab&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Chaîne de caractères vide&lt;/h2&gt;

&lt;p&gt;Une variable de type &lt;code&gt;string&lt;/code&gt; possède une &amp;ldquo;valeur&amp;rdquo; initiale particulière : &lt;code&gt;null&lt;/code&gt;. Il s&amp;rsquo;agit plutôt d&amp;rsquo;un mot-clé qui signifie : absence de valeur. Il ne faut pas le confondre avec la chaîne vide (&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string msg1;        // msg1 n&#39;a pas de valeur
string msg2 = &amp;quot;&amp;quot;;   // la valeur de msg2 est &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Structures alternatives</title>
      <link>http://prof.bpesquet.fr/cours/structures-alternatives</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/structures-alternatives</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est de découvrir comment enrichir nos programmes en leur ajoutant des possibilités d&amp;rsquo;exécution conditionnelle.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Le programme d&amp;rsquo;exemple&lt;/h1&gt;

&lt;p&gt;Le programme ci-dessous permet de comparer deux nombres entiers saisis par l&amp;rsquo;utilisateur.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.Write(&amp;quot;Entrez un premier nombre : &amp;quot;);
string saisie = Console.ReadLine();
int nombre1 = Convert.ToInt32(saisie);
Console.Write(&amp;quot;Entrez un second nombre : &amp;quot;);
saisie = Console.ReadLine();
int nombre2 = Convert.ToInt32(sais
if (nombre1 &amp;lt; nombre2)
{
    Console.WriteLine(&amp;quot;Le premier nombre est plus petit que le second&amp;quot;);
}
else
{
    if (nombre1 &amp;gt; nombre2)
    {
        Console.WriteLine(&amp;quot;Le premier nombre est plus grand que le second&amp;quot;);
    }
    else
    {
        Console.WriteLine(&amp;quot;Les deux nombres sont égaux&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;L&amp;rsquo;instruction &lt;code&gt;if&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Pour fonctionner, notre programme d&amp;rsquo;exemple a besoin de déterminer si le premier nombre saisi est inférieur au second. Pour cela, il utilise une nouvelle structure : l&amp;rsquo;instruction &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Syntaxe et fonctionnement&lt;/h2&gt;

&lt;p&gt;La syntaxe du &lt;code&gt;if&lt;/code&gt; est la suivante.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (condition)
{
    &amp;lt;instructions&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les accolades ouvrantes et fermantes délimitent ce qu&amp;rsquo;on appelle une unité de code source, appelée également &lt;strong&gt;bloc de code&lt;/strong&gt;. Si la condition placée après l&amp;rsquo;instruction &lt;code&gt;if&lt;/code&gt; est &lt;strong&gt;vraie&lt;/strong&gt;, alors les instructions contenues dans le bloc de code seront exécutées. Les parenthèses qui délimitent la condition sont indispensables en C#.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;L&amp;rsquo;instruction &lt;code&gt;if&lt;/code&gt; permet d&amp;rsquo;exécuter ou non des instructions selon la valeur d&amp;rsquo;une &lt;strong&gt;condition&lt;/strong&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;On observe que les instructions du bloc associé au &lt;code&gt;if&lt;/code&gt; sont décalées par rapport à l&amp;rsquo;instruction qui les contient. On dit qu&amp;rsquo;elles sont &lt;strong&gt;indentées&lt;/strong&gt; . Bien indenter ses programmes est une habitude importante à acquérir.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;La notion de condition&lt;/h2&gt;

&lt;p&gt;Voici un court extrait du premier exemple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
if (nombre1 &amp;lt; nombre2)
{
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;instruction &lt;code&gt;if&lt;/code&gt; est associée à la condition &lt;code&gt;(nombre1 &amp;lt; nombre2)&lt;/code&gt;. Cette condition est ce que l&amp;rsquo;on appelle une &lt;strong&gt;expression&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Une &lt;strong&gt;expression&lt;/strong&gt; est un ensemble de valeurs, de variables et d&amp;rsquo;opérateurs qui produit un résultat.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Ici, le résultat dépend de la valeur de la variable &lt;em&gt;nombre&lt;/em&gt; au moment de l&amp;rsquo;exécution :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;si &lt;code&gt;nombre1&lt;/code&gt; est strictement inférieur à &lt;code&gt;nombre2&lt;/code&gt;, le résultat de l&amp;rsquo;expression est &lt;strong&gt;vrai&lt;/strong&gt; (&lt;code&gt;true&lt;/code&gt; en C#).&lt;/li&gt;
&lt;li&gt;si &lt;code&gt;nombre1&lt;/code&gt; est supérieur ou égal à &lt;code&gt;nombre2&lt;/code&gt;, le résultat de l&amp;rsquo;expression est &lt;strong&gt;faux&lt;/strong&gt; (&lt;code&gt;false&lt;/code&gt; en C#).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Autrement dit, l&amp;rsquo;expression &lt;code&gt;(nombre1 &amp;lt; nombre2)&lt;/code&gt; renvoie une valeur de type &lt;strong&gt;booléen&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Toute expression renvoyant une valeur booléenne peut être utilisée comme condition avec un &lt;code&gt;if&lt;/code&gt;. C&amp;rsquo;est le cas des expressions utilisant des opérateurs de comparaison, dont voici la liste.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opérateur&lt;/th&gt;
&lt;th&gt;Signification&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Egal à&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Différent de&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inférieur strictement&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inférieur ou égal&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Supérieur strictement&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Supérieur ou égal&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&#34;alert alert-danger&#34;&gt;
    &lt;strong&gt;Danger !&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La plupart des langages de programmation utilisent le symbole &lt;code&gt;=&lt;/code&gt; pour symboliser l&amp;rsquo;affectation d&amp;rsquo;une valeur, et le symbole &lt;code&gt;==&lt;/code&gt; pour l&amp;rsquo;égalité. Attention aux confusions avec le sens mathématique de l&amp;rsquo;opérateur &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;L&amp;rsquo;instruction &lt;code&gt;else&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Dans notre exemple, on souhaite agir de manière alternative en fonction du résultat de la condition &lt;code&gt;(nombre1 &amp;lt; nombre2)&lt;/code&gt;. Le message à afficher est différent selon que cette condition soit vraie ou fausse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
if (nombre1 &amp;lt; nombre2)
{
    // Code exécuté si nombre1 &amp;lt; nombre2
    Console.WriteLine(&amp;quot;Le premier nombre est inférieur au second&amp;quot;);
}
else
{
    // Code exécuté si nombre1 &amp;gt;= nombre2
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Syntaxe et fonctionnement&lt;/h2&gt;

&lt;p&gt;Une alternative s&amp;rsquo;exprime grâce à l&amp;rsquo;instruction &lt;code&gt;if&lt;/code&gt; à laquelle on associe une instruction &lt;code&gt;else&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (condition)
{
    &amp;lt;instructions exécutées si la condition est vraie&amp;gt;
}
else
{
    &amp;lt;instructions exécutées si la condition est fausse&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On peut la traduire par : si la condition est vraie alors exécuter les instructions du bloc &lt;code&gt;if&lt;/code&gt;, sinon exécuter les instructions du bloc &lt;code&gt;else&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;L&amp;rsquo;instruction &lt;code&gt;if ... else ...&lt;/code&gt; permet de créer un &lt;strong&gt;branchement logique&lt;/strong&gt; à l&amp;rsquo;intérieur d&amp;rsquo;un programme. Pendant l&amp;rsquo;exécution, les instructions exécutées seront différentes selon la valeur de la condition. Un seul des deux blocs d&amp;rsquo;instructions sera pris en compte.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Il est fortement conseillé de toujours indenter les instructions contenues dans les blocs &lt;code&gt;if&lt;/code&gt; et &lt;code&gt;else&lt;/code&gt; par rapport à l&amp;rsquo;instruction qui les contient.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Instructions &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; imbriquées&lt;/h2&gt;

&lt;p&gt;Notre programme d&amp;rsquo;exemple intégre la possibilité que les deux nombres saisis soient égaux.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
if (nombre1 &amp;lt; nombre2)
{
    Console.WriteLine(&amp;quot;Le premier nombre est plus petit que le second&amp;quot;);
}
else
{
    // Code exécuté si nombre1 &amp;gt;= nombre2 
    if (nombre1 &amp;gt; nombre2)
    {
        // Code exécuté si nombre1 &amp;gt; nombre2 
        Console.WriteLine(&amp;quot;Le premier nombre est plus grand que le second&amp;quot;);
    }
    else
    {
        // Code exécuté si nombre1 = nombre2 
        Console.WriteLine(&amp;quot;Les deux nombres sont égaux&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il est possible de représenter graphiquement le flux d&amp;rsquo;exécution du programme d&amp;rsquo;exemple au moyen d&amp;rsquo;un &lt;strong&gt;diagramme de flux&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/flux_comparaison.png&#34; class=&#34;content centered&#34; alt=&#34;flux_comparaison.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Une instruction &lt;code&gt;if&lt;/code&gt; peut être placée à l&amp;rsquo;intérieur d&amp;rsquo;un bloc d&amp;rsquo;une autre instruction &lt;code&gt;if&lt;/code&gt;. C&amp;rsquo;est ce qu&amp;rsquo;on appelle &lt;strong&gt;imbriquer des conditions&lt;/strong&gt;. Il n&amp;rsquo;y a pas de limite (si ce n&amp;rsquo;est la lisibilité du programme) au niveau de profondeur des imbrications. Grâce à l&amp;rsquo;indentation des instructions, on visualise bien les différents blocs de code crées par les instructions &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
    &lt;strong&gt;Avertissement&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;A chaque accolade ouvrante doit correspondre une accolade fermante.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Omission des accolades&lt;/h2&gt;

&lt;p&gt;Dans le cas où le bloc de code associé à un &lt;code&gt;if&lt;/code&gt; ou à un &lt;code&gt;else&lt;/code&gt; ne comporte qu&amp;rsquo;une seule instruction, il est possible d&amp;rsquo;omettre les accolades. Notre programme d&amp;rsquo;exemple pourrait être réécrit comme ci-dessous.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
if (nombre1 &amp;lt; nombre2)
    Console.WriteLine(&amp;quot;Le premier nombre est plus petit que le second&amp;quot;);
else
    if (nombre1 &amp;gt; nombre2)
        Console.WriteLine(&amp;quot;Le premier nombre est plus grand que le second&amp;quot;);
    else
        Console.WriteLine(&amp;quot;Les deux nombres sont égaux&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-success&#34;&gt;
    &lt;strong&gt;Conseil&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;En phase d&amp;rsquo;apprentissage, il est conseillé d&amp;rsquo;ajouter systématiquement des accolades pour éviter les mauvaises surprises.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;L&amp;rsquo;instruction &lt;code&gt;switch&lt;/code&gt;&lt;/h1&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Le programme d&amp;rsquo;exemple&lt;/h2&gt;

&lt;p&gt;Le programme ci-dessous conseille l&amp;rsquo;utilisateur sur la tenue à porter en fonction de la météo actuelle.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.Write(&amp;quot;Fait-il froid dehors ? (1 = un peu, 2 = beaucoup, 3 = à la folie) : &amp;quot;);
string froid = Console.ReadLine();
switch (froid)
{
    case &amp;quot;1&amp;quot;:
        Console.WriteLine(&amp;quot;Sortez en pull.&amp;quot;);
        break;
    case &amp;quot;2&amp;quot;:
        Console.WriteLine(&amp;quot;Sortez en blouson.&amp;quot;);
        break;
    case &amp;quot;3&amp;quot;:
        Console.WriteLine(&amp;quot;Restez au chaud à la maison !&amp;quot;);
        break;
    default:
        Console.WriteLine(&amp;quot;Choix incorrect.&amp;quot;);
        break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Syntaxe et fonctionnement&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;instruction &lt;code&gt;if&lt;/code&gt; ne permet de gérer qu&amp;rsquo;une condition booléenne vraie ou faux. Dans certains cas, on souhaiterait plutôt pouvoir déclencher un traitement en fonction d&amp;rsquo;un choix possible parmi plusieurs plutôt que d&amp;rsquo;imbriquer des &lt;code&gt;if ... else ...&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;instruction &lt;code&gt;switch&lt;/code&gt; offre la possibilité de répondre de manière appropriée à la valeur saisie. Elle déclenche l&amp;rsquo;exécution d&amp;rsquo;un bloc d&amp;rsquo;instructions parmi plusieurs possibles. Seul le bloc correspondant à la valeur testée sera pris en compte.&lt;/p&gt;

&lt;p&gt;Sa syntaxe est la suivante.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch (variable)
{
case valeur1:
    &amp;lt;instructions&amp;gt;
    break;
case valeur2:
    &amp;lt;instructions&amp;gt;
    break;
...
default:
    &amp;lt;instructions&amp;gt;
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il n&amp;rsquo;y a pas de limite au nombre de cas possibles. Le mot-clé &lt;code&gt;default&lt;/code&gt;, à placer en fin de &lt;code&gt;switch&lt;/code&gt;, est optionnel. Il sert souvent à gérer les cas d&amp;rsquo;erreurs, comme ci-dessus.&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
    &lt;strong&gt;Avertissement&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Les instructions &lt;code&gt;break&lt;/code&gt; dans les blocs &lt;code&gt;case&lt;/code&gt; sont indispensables pour éviter de passer d&amp;rsquo;un bloc à un autre.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;Conditions complexes&lt;/h1&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;L&amp;rsquo;opérateur logique &amp;amp;&amp;amp;&lt;/h2&gt;

&lt;p&gt;Supposons qu&amp;rsquo;on souhaite savoir si la valeur d&amp;rsquo;une variable &lt;code&gt;X&lt;/code&gt; est comprise entre 100 et 150.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/intervalle_dedans.jpg&#34; class=&#34;content centered&#34; alt=&#34;intervalle_dedans.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pour cela, il faut regarder si la valeur de &lt;code&gt;X&lt;/code&gt; est à la fois supérieure ou égale à 100 et inférieure ou égale à 150. L&amp;rsquo;expression associée serait : &lt;code&gt;(X &amp;gt;= 100) ET (X &amp;lt;= 150)&lt;/code&gt;. Cette condition est formée de deux sous-conditions qui doivent être vérifiées simultanément pour que le résultat soit vrai.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;L&amp;rsquo;expression &lt;code&gt;100 ≤ X ≤ 150&lt;/code&gt; est mathématiquement valable mais ne peut pas s&amp;rsquo;employer en programmation.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;En C# comme dans de nombreux autres langages, l&amp;rsquo;opérateur logique &lt;strong&gt;ET&lt;/strong&gt; s&amp;rsquo;écrit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.Write(&amp;quot;Entrez X : &amp;quot;);
string saisie = Console.ReadLine();
double X = Convert.ToDouble(saisie);
if ((X &amp;gt;= 100) &amp;amp;&amp;amp; (X &amp;lt;= 150))
{
    Console.WriteLine(&amp;quot;X est compris entre 100 et 150&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avec l&amp;rsquo;opérateur &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, la seule manière d&amp;rsquo;avoir un résultat vrai est que les deux sous-conditions soient vraies.&lt;/p&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;L&amp;rsquo;opérateur logique ||&lt;/h2&gt;

&lt;p&gt;On pourrait égaler souhaiter vérifier le fait que &lt;code&gt;X&lt;/code&gt; soit en dehors de
l&amp;rsquo;intervalle [100:150].&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/intervalle_dehors.jpg&#34; class=&#34;content centered&#34; alt=&#34;intervalle_dehors.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ici, &lt;code&gt;X&lt;/code&gt; peut être soit inférieur à 100, soit supérieur à 150. L&amp;rsquo;expression correspondante est &lt;code&gt;(X &amp;lt; 100) OU (X &amp;gt; 150)&lt;/code&gt;. Il suffit que l&amp;rsquo;une ou l&amp;rsquo;autre des sous-conditions soit remplie pour que le résultat
soit vrai.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;opérateur logique &lt;strong&gt;OU&lt;/strong&gt; s&amp;rsquo;écrit en C# &lt;code&gt;||&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
if ((X &amp;lt; 100) || (X &amp;gt; 150))
{
    Console.WriteLine(&amp;quot;X est inférieur à 100 ou supérieur à 150&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avec l&amp;rsquo;opérateur &lt;code&gt;||&lt;/code&gt;, la seule manière d&amp;rsquo;avoir un résultat faux est que les deux conditions soient fausses.&lt;/p&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;L&amp;rsquo;opérateur logique !&lt;/h2&gt;

&lt;p&gt;Exprimer le fait que &lt;code&gt;X&lt;/code&gt; soit en dehors de l&amp;rsquo;intervalle [100:150] revient à prendre l&amp;rsquo;inverse de la condition qui vérifie que &lt;code&gt;X&lt;/code&gt; est à l&amp;rsquo;intérieur de cet intervalle. Autrement dit, l&amp;rsquo;expression
&lt;code&gt;(X &amp;lt; 100) OU (X &amp;gt; 150)&lt;/code&gt; est équivalente à &lt;code&gt;Non((X &amp;gt;= 100) ET (X &amp;lt;= 150))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;opérateur logique &lt;strong&gt;NON&lt;/strong&gt; qui inverse la valeur d&amp;rsquo;une condition booléenne s&amp;rsquo;écrit en C# &lt;code&gt;!&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
if (!((X &amp;gt;= 100) &amp;amp;&amp;amp; (X &amp;lt;= 150)))
{
    Console.WriteLine(&amp;quot;X est inférieur à 100 ou supérieur à 150&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Structures répétitives</title>
      <link>http://prof.bpesquet.fr/cours/structures-repetitives</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/structures-repetitives</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est d&amp;rsquo;apprendre comment ajouter à nos programmes des possibilités d&amp;rsquo;exécution répétitive.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Définition&lt;/h1&gt;

&lt;p&gt;Une structure répétitive, également appelée structure itérative ou encore &lt;strong&gt;boucle&lt;/strong&gt;, permet de répéter plusieurs fois l&amp;rsquo;exécution d&amp;rsquo;une ou plusieurs instructions. Le nombre de répétitions peut :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;être connu à l&amp;rsquo;avance.&lt;/li&gt;
&lt;li&gt;dépendre de l&amp;rsquo;évaluation d&amp;rsquo;une &lt;strong&gt;condition&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A chaque répétition, les instructions contenues dans la boucle sont exécutées. C&amp;rsquo;est ce qu&amp;rsquo;on appelle un tour de boucle ou encore une &lt;strong&gt;itération&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/repetitives_bart.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;repetitives_bart.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les structures répétitives sont très utilisées en programmation. Leur maîtrise est donc essentielle.&lt;/p&gt;

&lt;p&gt;Il existe deux grands types de boucles, supportées par la grande majorité des langages de programmation. Nous allons les étudier successivement.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;La boucle &lt;code&gt;while&lt;/code&gt;&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Le programme d&amp;rsquo;exemple&lt;/h2&gt;

&lt;p&gt;Prenons comme exemple un programme C# qui répète plusieurs fois des instructions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Début du programme&amp;quot;);
int compteur = 0;
while (compteur &amp;lt; 10)
{
    compteur++;
    Console.WriteLine(&amp;quot;Dans la boucle, tour numéro &amp;quot; + compteur);
}
Console.WriteLine(&amp;quot;Vous avez effectué &amp;quot; + compteur + &amp;quot; tour(s) de boucle&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/while_For.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;while_For.jpg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Syntaxe et fonctionnement&lt;/h2&gt;

&lt;p&gt;La syntaxe de l&amp;rsquo;instruction &lt;code&gt;while&lt;/code&gt; est la suivante.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (condition)
{
    &amp;lt;instructions&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avant chaque tour de boucle, la condition associée au &lt;code&gt;while&lt;/code&gt; est évaluée :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;si elle est vraie, les instructions du bloc &lt;code&gt;while&lt;/code&gt; sont exécutées. Ensuite, la ligne du &lt;code&gt;while&lt;/code&gt; est à nouveau exécutée et la condition vérifiée.&lt;/li&gt;
&lt;li&gt;si elle est fausse, les instructions du bloc ne sont pas exécutées et le programme continue juste après le bloc &lt;code&gt;while&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La boucle &lt;code&gt;while&lt;/code&gt;, appelée également boucle TantQue, permet de répéter des instructions &lt;strong&gt;tant qu&amp;rsquo;une condition est vérifiée&lt;/strong&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Nombre de tours de boucle&lt;/h2&gt;

&lt;p&gt;Il est important de définir précisement la condition associée à la boucle &lt;code&gt;while&lt;/code&gt; afin d&amp;rsquo;effectuer le bon nombre de tours de boucle. Voici l&amp;rsquo;exemple précédent réécrit en initialisant la variable `compteur à 1 et non plus à 0.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Début du programme&amp;quot;);
int compteur = 1;
while (compteur &amp;lt;= 10)  // &amp;lt;= au lieu de &amp;lt;
{
    Console.WriteLine(&amp;quot;Dans la boucle, tour numéro &amp;quot; + compteur);
    compteur++;  // Instruction déplacée après la précédente
}
Console.WriteLine(&amp;quot;Vous avez effectué &amp;quot; + (compteur - 1) + &amp;quot; tour(s) de boucle&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il produit exactement le même résultat d&amp;rsquo;exécution.&lt;/p&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Le bloc d&amp;rsquo;instructions associé au while est appelé &lt;strong&gt;corps de la boucle&lt;/strong&gt;. Il doit être placé entre accolades, sauf s&amp;rsquo;il ne comporte qu&amp;rsquo;une seule instruction (TODO).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Il existe aussi des situations où la condition du &lt;code&gt;while&lt;/code&gt; dépend d&amp;rsquo;une saisie demandée à l&amp;rsquo;utilisateur.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string saisie;
bool continuer = true;
while (continuer)
{
    Console.Write(&amp;quot;Pour sortir de la boucle, tapez 0 : &amp;quot;);
    saisie = Console.ReadLine();
    if (saisie == &amp;quot;0&amp;quot;)
        continuer = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans ce cas, il est impossible de prévoir à l&amp;rsquo;avance le nombre de tours de boucles réalisés.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;la boucle &lt;code&gt;for&lt;/code&gt;&lt;/h1&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Le programme d&amp;rsquo;exemple&lt;/h2&gt;

&lt;p&gt;Voici notre programme d&amp;rsquo;exemple initial réécrit d&amp;rsquo;une autre manière.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Début du programme&amp;quot;);
int compteur;
for (compteur = 0; compteur &amp;lt; 10; compteur++)
{
    Console.WriteLine(&amp;quot;Dans la boucle, tour numéro &amp;quot; + (compteur + 1));
}
Console.WriteLine(&amp;quot;Vous avez effectué &amp;quot; + compteur + &amp;quot; tour(s) de boucle&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/while_For.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;while_For.jpg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Syntaxe et fonctionnement&lt;/h2&gt;

&lt;p&gt;La syntaxe de l&amp;rsquo;instruction &lt;code&gt;for&lt;/code&gt; est la suivante.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (initialisation; condition; étape)
{
    &amp;lt;instructions&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voici son fonctionnement :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L&amp;rsquo;initialisation (&lt;code&gt;compteur = 0&lt;/code&gt; dans l&amp;rsquo;exemple) se produit une seule fois, au début de l&amp;rsquo;exécution de la boucle.&lt;/li&gt;
&lt;li&gt;La condition (&lt;code&gt;compteur &amp;lt; 10&lt;/code&gt; dans l&amp;rsquo;exemple) est évaluée &lt;strong&gt;avant chaque tour de boucle&lt;/strong&gt;. Si elle est vraie, un nouveau tour de boucle est effectué. Sinon, la boucle est terminée.&lt;/li&gt;
&lt;li&gt;L&amp;rsquo;étape (&lt;code&gt;compteur++&lt;/code&gt; dans l&amp;rsquo;exemple) est réalisée &lt;strong&gt;après chaque tour de boucle&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A la fin de l&amp;rsquo;exécution de l&amp;rsquo;exemple précédent, la variable `compteur possède donc la valeur &lt;em&gt;10&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La boucle &lt;code&gt;for&lt;/code&gt;, appelée également boucle Pour, permet de répéter des instructions &lt;strong&gt;tant qu&amp;rsquo;une condition est vérifiée&lt;/strong&gt;. Elle permet de définir une initialisation qui a lieu une seule fois et une étape qui a lieu après chaque tour de boucle.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;L&amp;rsquo;opérateur &lt;code&gt;++&lt;/code&gt; est un raccourci : écrire &lt;code&gt;variable++&lt;/code&gt; équivaut à écrire &lt;code&gt;variable = variable + 1&lt;/code&gt;, en plus concis. L&amp;rsquo;opérateur &lt;code&gt;++&lt;/code&gt; est appelé opérateur de post-incrémentation.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;L&amp;rsquo;opération qui consiste à ajouter 1 à la valeur d&amp;rsquo;une variable entière se nomme &lt;strong&gt;l&amp;rsquo;incrémentation&lt;/strong&gt;
(&lt;a href=&#34;http://fr.wikipedia.org/wiki/Incr%C3%A9mentation&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La variable utilisée dans l&amp;rsquo;initialisation, la condition et l&amp;rsquo;étape est appelée le &lt;em&gt;`compteur&lt;/em&gt; de la boucle. Par convention, on la nomme souvent &lt;em&gt;i&lt;/em&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Nombre de tours de boucle&lt;/h2&gt;

&lt;p&gt;Comme avec un &lt;code&gt;while&lt;/code&gt;, l&amp;rsquo;initialisation et la condition d&amp;rsquo;une boucle &lt;code&gt;for&lt;/code&gt; doivent être définies avec précision. Voici l&amp;rsquo;exemple précédent réécrit en initialisant la variable &lt;code&gt;compteur&lt;/code&gt; à 1 et non plus à 0.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Début du programme&amp;quot;);
int compteur;
for (compteur = 1; compteur &amp;lt;= 10; compteur++)
{
    Console.WriteLine(&amp;quot;Dans la boucle, tour numéro &amp;quot; + compteur);
}
Console.WriteLine(&amp;quot;Vous avez effectué &amp;quot; + (compteur - 1) + &amp;quot; tour(s) de boucle&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il produit exactement le même résultat d&amp;rsquo;exécution, mais la valeur finale de la variable &lt;code&gt;compteur&lt;/code&gt; est 11 et non plus 10.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Portée du compteur de boucle&lt;/h2&gt;

&lt;p&gt;Lorsqu&amp;rsquo;on n&amp;rsquo;a pas besoin d&amp;rsquo;utiliser la variable compteur de boucle en dehors du corps de la boucle, on peut déclarer cette variable dans l&amp;rsquo;initialisation de la boucle &lt;code&gt;for&lt;/code&gt; qui l&amp;rsquo;utilise.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
for (int compteur = 0; compteur &amp;lt; 10; compteur++)
{
    // ...
}
// Impossible d&#39;utiliser la variable compteur après la boucle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans ce cas, sa &lt;strong&gt;portée&lt;/strong&gt; se limite au corps de la boucle, entre les accolades.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La &lt;strong&gt;portée&lt;/strong&gt; d&amp;rsquo;une variable est l&amp;rsquo;ensemble des endroits d&amp;rsquo;un programme où cette variable est utilisable.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;Choix entre un &lt;code&gt;while&lt;/code&gt; et un &lt;code&gt;for&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Certains contextes sont plus adaptés à l&amp;rsquo;utilisation d&amp;rsquo;une boucle &lt;code&gt;while&lt;/code&gt;, d&amp;rsquo;autre à celui d&amp;rsquo;un &lt;code&gt;for&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ces deux structures permettent de répéter plusieurs fois un ensemble d&amp;rsquo;instructions. La différence essentielle est que le nombre d&amp;rsquo;itérations d&amp;rsquo;un &lt;code&gt;for&lt;/code&gt; est fixé au début de l&amp;rsquo;exécution de la boucle.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;si on peut prévoir à l&amp;rsquo;avance le nombre de tours de boucle, le &lt;code&gt;for&lt;/code&gt; est préférable.&lt;/li&gt;
&lt;li&gt;sinon, il faut utiliser un &lt;code&gt;while&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;Erreurs à éviter&lt;/h1&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Boucle &lt;code&gt;while&lt;/code&gt; infinie&lt;/h2&gt;

&lt;p&gt;Le principal risque lié à la boucle &lt;code&gt;while&lt;/code&gt; est la &lt;strong&gt;boucle infinie&lt;/strong&gt;. Il s&amp;rsquo;agit d&amp;rsquo;une erreur de programmation très facile à commettre, donc dangereuse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Le manège démarre !&amp;quot;);
int tour = 1;
while (tour &amp;lt;= 10)  // Toujours vraie =&amp;gt; boucle infinie
{
    Console.WriteLine(&amp;quot;C&#39;est le tour numéro &amp;quot; + tour);
}
Console.WriteLine(&amp;quot;Le manège s&#39;arrête&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A l&amp;rsquo;exécution, on ne sortira jamais du corps de la boucle puisque la variable &lt;code&gt;tour&lt;/code&gt; vaudra toujours 1.&lt;/p&gt;

&lt;p&gt;Pour corriger ce problème, il faut ajouter l&amp;rsquo;instruction &lt;code&gt;tour++&lt;/code&gt; dans le corps de la boucle.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Le manège démarre !&amp;quot;);
int tour = 1;
while (tour &amp;lt;= 10)  // Deviendra fausse quand tour &amp;gt; 10
{
    Console.WriteLine(&amp;quot;C&#39;est le tour numéro &amp;quot; + tour);
    tour++;
}
Console.WriteLine(&amp;quot;Le manège s&#39;arrête&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Une boucle infinie est une boucle mal écrite, dont la condition reste toujours vraie.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Pour éviter de créer une boucle infinie, il faut :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;écrire une condition de boucle correcte.&lt;/li&gt;
&lt;li&gt;initialiser correctement la ou les variables impliquées dans la  condition de la boucle.&lt;/li&gt;
&lt;li&gt;vérifier que ces variables sont modifiées dans le corps de la boucle pour rendre la condition fausse le moment venu.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Manipulation du compteur d&amp;rsquo;une boucle &lt;code&gt;for&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Imaginons qu&amp;rsquo;on ait l&amp;rsquo;idée (bizarre) de manipuler le compteur d&amp;rsquo;une boucle &lt;code&gt;for&lt;/code&gt; dans le corps de la boucle.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.WriteLine(&amp;quot;Début du programme&amp;quot;);
for (int i = 1; i &amp;lt;= 10; i++)
{
     Console.WriteLine(&amp;quot;Dans la boucle, tour numéro &amp;quot; + i);
     i = i + 1;  // Danger !
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A chaque tour de boucle, le compteur est incrémenté deux fois : une fois dans le corps de la boucle puis une seconde fois dans l&amp;rsquo;étape.&lt;/p&gt;

&lt;div class=&#34;alert alert-danger&#34;&gt;
    &lt;strong&gt;Danger !&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Quand on emploie une boucle &lt;code&gt;for&lt;/code&gt;, l&amp;rsquo;incrémentation du compteur de boucle est automatique après chaque tour de boucle. Sauf exception rarissime, Il ne faut donc surtout pas modifier cette variable à l&amp;rsquo;intérieur de la boucle.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Tableaux et listes</title>
      <link>http://prof.bpesquet.fr/cours/tableaux-listes</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://prof.bpesquet.fr/cours/tableaux-listes</guid>
      <description>

&lt;p&gt;L&amp;rsquo;objectif de ce chapitre est de présenter deux manières de regrouper des données en mémoire : les tableaux et les listes (appelées parfois collections).&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Jusqu&amp;rsquo;à présent, nos programmes ont utilisé uniquement des variables stockant une seule valeur, appelées parfois des variables &lt;em&gt;scalaires&lt;/em&gt; (&lt;a href=&#34;http://fr.wikipedia.org/wiki/Scalaire#Informatique&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;On souhaite écrire un programme qui fait saisir 5 valeurs à l&amp;rsquo;utilisateur, puis calcule et affiche leur somme. Une solution pourrait être la suivante.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Console.Write(&amp;quot;Entrez le nombre 1 : &amp;quot;);
int nb1 = Convert.ToInt32(Console.ReadLine());
Console.Write(&amp;quot;Entrez le nombre 2 : &amp;quot;);
int nb2 = Convert.ToInt32(Console.ReadLine());
Console.Write(&amp;quot;Entrez le nombre 3 : &amp;quot;);
int nb3 = Convert.ToInt32(Console.ReadLine());
Console.Write(&amp;quot;Entrez le nombre 4 : &amp;quot;);
int nb4 = Convert.ToInt32(Console.ReadLine());
Console.Write(&amp;quot;Entrez le nombre 5 : &amp;quot;);
int nb5 = Convert.ToInt32(Console.ReadLine());

Console.WriteLine(&amp;quot;Le nombre 1 est &amp;quot; + nb1);
Console.WriteLine(&amp;quot;Le nombre 2 est &amp;quot; + nb2);
Console.WriteLine(&amp;quot;Le nombre 3 est &amp;quot; + nb3);
Console.WriteLine(&amp;quot;Le nombre 4 est &amp;quot; + nb4);
Console.WriteLine(&amp;quot;Le nombre 5 est &amp;quot; + nb5);

int somme = nb1 + nb2 + nb3 + nb4 + nb5;
Console.WriteLine(&amp;quot;Leur somme vaut &amp;quot; + somme);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans cet exemple, il est nécessaire de créer une variable par nombre saisi. Mais comment faire si on veut gérer non pas 5, mais 50 ou même 500 nombres ? Déclarer et saisir autant de nombres ferait exploser la taille de notre programme, avec des traitements (saisie, affichage, calcul) très répétitifs. On doit pouvoir faire mieux.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Les tableaux&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Définition&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Un &lt;strong&gt;tableau&lt;/strong&gt; regroupe un ensemble d&amp;rsquo;éléments de même nature. Une variable de type &amp;ldquo;tableau&amp;rdquo; permet de stocker plusieurs éléments partageant le même &lt;strong&gt;type&lt;/strong&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;On pourra donc utiliser des tableaux d&amp;rsquo;entiers, des tableaux de chaînes, voire même des tableaux de tableaux&amp;hellip;&lt;/p&gt;

&lt;p&gt;On peut représenter graphiquement un tableau sous la forme d&amp;rsquo;un ensemble de cases. Chaque case permet de stocker une valeur spécifique. Cette représentation peut être horizontale ou verticale.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exemple de représentation horizontale (&lt;em&gt;tableau 1&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Indice&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;16&lt;/th&gt;
&lt;th&gt;17&lt;/th&gt;
&lt;th&gt;18&lt;/th&gt;
&lt;th&gt;19&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;&lt;code&gt;valeur&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;td&gt;41&lt;/td&gt;
&lt;td&gt;43&lt;/td&gt;
&lt;td&gt;47&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;59&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;td&gt;71&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Exemple de représentation verticale (&lt;em&gt;tableau 2&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Indice&lt;/th&gt;
&lt;th&gt;Valeur&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Annie ZETTE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Léon DIT&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Ali GATOR&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Sam GRATE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Pierre KIROUL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Le numéro d&amp;rsquo;une case d&amp;rsquo;un tableau est appelée son &lt;strong&gt;indice&lt;/strong&gt;. Pour accéder à un élément du tableau, il faut donc connaître son indice.&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
    &lt;strong&gt;Avertissement&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;En C# et dans la plupart des autres langages, les tableaux sont indicés à partir de 0 et non de 1.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Caractéristiques&lt;/h2&gt;

&lt;p&gt;Un tableau se caractérise par :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;le type des éléments qu&amp;rsquo;il stocke.&lt;/li&gt;
&lt;li&gt;le nombre des éléments qu&amp;rsquo;il stocke, appelé sa &lt;strong&gt;taille&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tableau&lt;/th&gt;
&lt;th&gt;Type des éléments stockés&lt;/th&gt;
&lt;th&gt;Taille&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Tableau 1&lt;/td&gt;
&lt;td&gt;Entier&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tableau 2&lt;/td&gt;
&lt;td&gt;Chaîne&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&#34;alert&#34;&gt;
    &lt;strong&gt;Remarque&lt;/strong&gt;
    &lt;p&gt;&lt;ul&gt;
&lt;li&gt;En C#, tous les éléments d&amp;rsquo;un tableau doivent avoir le même type. On ne peut pas mélanger des entiers, des réels ou des chaînes dans un même tableau.&lt;/li&gt;
&lt;li&gt;La taille d&amp;rsquo;un tableau est fixe, même si certains langages de programmation permettent de la modifier dynamiquement (pendant l&amp;rsquo;exécution du programme).&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Exemple d&amp;rsquo;utilisation&lt;/h2&gt;

&lt;p&gt;Voici notre exemple de début de chapitre, réécrit en utilisant un tableau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int[] nombres;
nombres = new int[5];

for (int i = 0; i &amp;lt; nombres.Length; i++)
{
    Console.Write(&amp;quot;Entrez le nombre &amp;quot; + (i + 1) + &amp;quot; : &amp;quot;);
    int nombreSaisi = Convert.ToInt32(Console.ReadLine());
    nombres[i] = nombreSaisi;
}

int somme = 0;
for (int i = 0; i &amp;lt; nombres.Length; i++)
{
    Console.WriteLine(&amp;quot;Le nombre &amp;quot; + (i + 1) + &amp;quot; est &amp;quot; + nombres[i]);
    somme = somme + nombres[i];
}
Console.WriteLine(&amp;quot;Leur somme vaut &amp;quot; + somme);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/tableau.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;tableau.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nous allons détailler tous les éléments nouveaux de ce programme.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Déclaration d&amp;rsquo;un tableau&lt;/h2&gt;

&lt;p&gt;On manipule un tableau grâce à une variable de type spécifique.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int[] nombres;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les &lt;strong&gt;crochets&lt;/strong&gt; indiquent que la variable déclarée est un tableau.&lt;/p&gt;

&lt;p&gt;Quand on déclare un tableau, on doit préciser :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;le &lt;strong&gt;nom&lt;/strong&gt; de la variable associée (ici &lt;code&gt;nombres&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;le &lt;strong&gt;type&lt;/strong&gt; des éléments du tableau (ici &lt;code&gt;int&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La syntaxe de définition d&amp;rsquo;un tableau en C# est donc la suivante.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typeElement[] nomTableau;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Allocation mémoire&lt;/h2&gt;

&lt;p&gt;Comme pour un objet, la simple déclaration d&amp;rsquo;un tableau de provoque pas de réservation mémoire pour stocker ses valeurs. Pour cela, il est nécessaire d&amp;rsquo;allouer la mémoire nécessaite en utilisant l&amp;rsquo;opérateur &lt;code&gt;new&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
nombres = new int[5];
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On précise entre crochets le nombre d&amp;rsquo;éléments du tableau, autrement dit sa &lt;strong&gt;taille&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Lors de l&amp;rsquo;exécution de cette ligne, une zone mémoire nécessaire au stockage de tous les éléments est réservée. Les valeurs initialement stockées dans le tableau sont inconnues.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Accès à un élément d&amp;rsquo;un tableau&lt;/h2&gt;

&lt;p&gt;Les éléments d&amp;rsquo;un tableau sont stockés dans des &amp;ldquo;cases&amp;rdquo; identifiées par leur &lt;strong&gt;indice&lt;/strong&gt;. Pour accéder à un élément, on doit donc utiliser cet indice.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double[] valeurs = new double[4];
valeurs[0] = 12.5;
valeurs[1] = 10;
valeurs[2] = 17.5;
valeurs[3] = 13;
double total = valeurs[0] + valeurs[1] + valeurs[2] + valeurs[3];
Console.WriteLine(total);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En fin d&amp;rsquo;exécution, la variable &lt;code&gt;total&lt;/code&gt; aura la valeur 53 et le contenu du tableau valeurs sera le suivant.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Indice&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;&lt;code&gt;valeur&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;12,5&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;17,5&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Parcours d&amp;rsquo;un tableau&lt;/h2&gt;

&lt;p&gt;Lorsqu&amp;rsquo;on veut effectuer un traitement répétitif sur un tableau, on utilise souvent une &lt;strong&gt;boucle&lt;/strong&gt; (TODO).&lt;/p&gt;

&lt;p&gt;Reprenons notre exemple précédent. Additionner tous les éléments d&amp;rsquo;un tableau revient à :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Initialiser une variable nommée &lt;code&gt;total&lt;/code&gt; à zéro.&lt;/li&gt;
&lt;li&gt;Parcourir le tableau avec une boucle et ajouter chaque élément à la variable &lt;code&gt;total&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Une fois le tableau parcouru, &lt;code&gt;total&lt;/code&gt; contiendra la somme de ses éléments, comme attendu.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Voici la traduction en C# de cet algorithme.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double[] valeurs = new double[4];
valeurs[0] = 12.5;
valeurs[1] = 10;
valeurs[2] = 17.5;
valeurs[3] = 13;
double total = 0;
for (int i = 0; i &amp;lt; valeurs.Length; i++)
{
    total = total + valeurs[i];
}
Console.WriteLine(total);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le nombre d&amp;rsquo;éléments d&amp;rsquo;un tableau étant connu à l&amp;rsquo;avance, le choix d&amp;rsquo;une boucle &lt;code&gt;for&lt;/code&gt; plutôt qu&amp;rsquo;une boucle &lt;code&gt;while&lt;/code&gt; est souvent judicieux.&lt;/p&gt;

&lt;p&gt;On constate que l&amp;rsquo;instruction C# &lt;code&gt;valeurs.Length&lt;/code&gt; permet de renvoyer la taille du tableau &lt;code&gt;valeurs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Le compteur de boucle &lt;code&gt;i&lt;/code&gt; prend successivement les valeurs 0, 1, 2, 3, ce qui correspond aux différents indices du tableau &lt;code&gt;valeurs&lt;/code&gt;. Le compteur va de 0 jusqu&amp;rsquo;à &lt;em&gt;taille du tableau - 1&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A titre d&amp;rsquo;exercice, on peut réécrire ce programme en utilisant une boucle &lt;code&gt;while&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
double total = 0;
int i = 0;
while (i &amp;lt; valeurs.Length)
{
    total = total + valeurs[i];
    i++;
}
Console.WriteLine(total);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Les listes&lt;/h1&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Limites des tableaux&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;utilisation d&amp;rsquo;un tableau permet de stocker un ensemble de plusieurs éléments de même nature. Cependant, les tableaux souffrent de plusieurs limitations :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;leur taille est fixée au moment de l&amp;rsquo;allocation mémoire.&lt;/li&gt;
&lt;li&gt;toutes les opérations courantes (tri, recherche d&amp;rsquo;un élément, etc) doivent être écrites manuellement par le programmeur.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le dépassement de capacité d&amp;rsquo;un tableau est une erreur de programmation classique.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/depassement_capacite_tableau.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;depassement_capacite_tableau.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Dans l&amp;rsquo;exemple ci-dessus, on tente de définir la valeur du 5ème élément d&amp;rsquo;un tableau de 4 éléments, ce qui provoque une erreur à l&amp;rsquo;exécution.&lt;/p&gt;

&lt;p&gt;Pour pallier à ces inconvénients, un autre type de donnée tend à les supplanter : les &lt;strong&gt;listes&lt;/strong&gt; (appelées parfois &lt;em&gt;collections&lt;/em&gt;).&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Définition&lt;/h2&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Comme un tableau, une &lt;strong&gt;liste&lt;/strong&gt; regroupe un ensemble d&amp;rsquo;éléments de même nature. Une variable de type &amp;ldquo;liste&amp;rdquo; permet de stocker plusieurs éléments partageant le même &lt;strong&gt;type&lt;/strong&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Cependant, une liste offre plus de fonctionnalités qu&amp;rsquo;un tableau. En particulier, sa taille (nombre d&amp;rsquo;éléments stockables) n&amp;rsquo;est pas fixe. Si besoin, une liste se redimensionne automatiquement lors de l&amp;rsquo;ajout d&amp;rsquo;un nouvel élément.&lt;/p&gt;

&lt;p&gt;Une liste est un &lt;strong&gt;objet&lt;/strong&gt; et dispose de plusieurs &lt;strong&gt;propriétés&lt;/strong&gt; et &lt;strong&gt;méthodes&lt;/strong&gt; pour gérer les éléments qu&amp;rsquo;elle contient.&lt;/p&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Exemple d&amp;rsquo;utilisation&lt;/h2&gt;

&lt;p&gt;Voici l&amp;rsquo;un des exemples précédents, réécrit en utilisant une liste.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;double&amp;gt; valeurs;          // déclaration
valeurs = new List&amp;lt;double&amp;gt;();  // instanciation

valeurs.Add(12.5);
valeurs.Add(10);
valeurs.Add(17.5);
valeurs.Add(13);

double total = 0;
for (int i = 0; i &amp;lt; valeurs.Count; i++)
{
    total = total + valeurs[i];
}
Console.WriteLine(total);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Déclaration d&amp;rsquo;une liste&lt;/h2&gt;

&lt;p&gt;En C#, on manipule une liste grâce à une variable de type &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;double&amp;gt; valeurs; 
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En observant la déclaration ci-dessus, on voit que le type des éléments stockés dans la liste (ici &lt;code&gt;double&lt;/code&gt;) est défini entre &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. La variable &lt;code&gt;valeurs&lt;/code&gt; est donc une liste de réels.&lt;/p&gt;

&lt;p&gt;Le type &lt;code&gt;List&lt;/code&gt; est une classe et la variable &lt;code&gt;valeurs&lt;/code&gt; est un objet. A ce titre, sa déclaration ne provoque aucune réservation mémoire. Pour cela, il faut instancier cet objet.&lt;/p&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Instanciation d&amp;rsquo;une liste&lt;/h2&gt;

&lt;p&gt;Comme pour tout objet, l&amp;rsquo;instanciation d&amp;rsquo;une liste se fait grâce à l&amp;rsquo;opérateur &lt;code&gt;new&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
valeurs = new List&amp;lt;double&amp;gt;();
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C&amp;rsquo;est cette opération qui déclenche la réservation d&amp;rsquo;une zone mémoire pour stocker les éléments de la liste. La taille initiale de la liste est fixée par le système. Elle n&amp;rsquo;a pas d&amp;rsquo;importance réelle, puisqu&amp;rsquo;une liste peut se redimensionner automatiquement.&lt;/p&gt;

&lt;h2 id=&#34;toc_15&#34;&gt;Ajout d&amp;rsquo;éléments à une liste&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// ...
valeurs.Add(12.5);
valeurs.Add(10);
valeurs.Add(17.5);
valeurs.Add(13);
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On utilise une méthode nommée &lt;code&gt;Add&lt;/code&gt; pour ajouter un élément à un objet liste. Elle prend en paramètre une valeur dont le type doit être compatible avec le type des éléments de la liste.&lt;/p&gt;

&lt;h2 id=&#34;toc_16&#34;&gt;Accès à un élément d&amp;rsquo;une liste&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;accès à un élément d&amp;rsquo;une liste peut se faire de plusieurs manières. Il est possible d&amp;rsquo;utiliser la même syntaxe que pour un tableau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
double total = valeurs[0] + valeurs[1] + valeurs[2] + valeurs[3];
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les éléments d&amp;rsquo;une liste sont stockés dans l&amp;rsquo;ordre de leur ajout :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;valeurs[0]&lt;/code&gt; représente le premier élément de la liste&lt;/li&gt;
&lt;li&gt;&lt;code&gt;valeurs[1]&lt;/code&gt; représente le deuxième élément de la liste&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comme un tableau, une liste est indicée à partir de zéro. Attention à ne pas aller au-delà de la taille de la liste, comme dans l&amp;rsquo;exemple ci-dessous.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/depassement_capacite_liste.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;depassement_capacite_liste.jpg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_17&#34;&gt;Itération sur une liste&lt;/h2&gt;

&lt;p&gt;Il existe deux solutions pour parcourir une liste élément après élément (on parle de parcours &lt;em&gt;séquentiel&lt;/em&gt;). La première consiste à utiliser la même syntaxe que pour un tableau, avec une boucle &lt;code&gt;for&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;double&amp;gt; valeurs = new List&amp;lt;double&amp;gt;();
// ...
double total = 0;
for (int i = 0; i &amp;lt; valeurs.Count; i++)
{
    total = total + valeurs[i];
}
Console.WriteLine(total);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On constate que l&amp;rsquo;instruction &lt;code&gt;valeurs.Count&lt;/code&gt; permet de renvoyer la taille (nombre d&amp;rsquo;éléments) de la liste &lt;code&gt;valeurs&lt;/code&gt;. &lt;code&gt;Count&lt;/code&gt; est une propriété C# de la classe &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Le compteur de boucle &lt;code&gt;i&lt;/code&gt; prend successivement les valeurs 0, 1, 2, 3. Le compteur va de 0 jusqu&amp;rsquo;à &lt;em&gt;taille de la liste - 1&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Le seconde possiblité de parcours d&amp;rsquo;une liste utilise un nouveau type de boucle, la boucle &lt;code&gt;foreach&lt;/code&gt; (&amp;ldquo;pour chaque&amp;rdquo;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;double&amp;gt; valeurs = new List&amp;lt;double&amp;gt;();
// ...
foreach (double valeur in valeurs)
{
    total = total + valeur;
}
Console.WriteLine(total);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La boucle &lt;code&gt;foreach&lt;/code&gt; parcourt la liste &lt;code&gt;valeurs&lt;/code&gt; élément après élément. A chaque tour de boucle, l&amp;rsquo;élément courant de la liste &lt;code&gt;valeurs&lt;/code&gt; est affecté à la variable locale &lt;code&gt;valeur&lt;/code&gt;, qui peut être utilisée dans le corps de la boucle.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
    &lt;strong&gt;Définition&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La boucle &lt;code&gt;foreach&lt;/code&gt; permet de parcourir une liste élément par élément.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;alert alert-success&#34;&gt;
    &lt;strong&gt;Conseil&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;La distinction singulier/pluriel est importante : &lt;code&gt;valeurs&lt;/code&gt; désigne la liste (type : &lt;code&gt;List&amp;lt;double&amp;gt;&lt;/code&gt;) et &lt;code&gt;valeur&lt;/code&gt; désigne son élément courant (type : &lt;code&gt;double&lt;/code&gt;).&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;La syntaxe de l&amp;rsquo;instruction &lt;code&gt;foreach&lt;/code&gt; est la suivante.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach (typeElement unElement in listeElements)
{
    &amp;lt;instructions utilisant unElement&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_18&#34;&gt;Liste d&amp;rsquo;objets&lt;/h2&gt;

&lt;p&gt;Les listes sont souvent utilisées pour stocker des objets, instances de classes. Reprenons la classe &lt;code&gt;CompteBancaire&lt;/code&gt; étudiée au chapitre précédent.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/uml_compte_bancaire_2.jpg&#34; class=&#34;content centered&#34; alt=&#34;uml_compte_bancaire_2.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On déclare une liste d&amp;rsquo;objets de la même manière que pour n&amp;rsquo;importe quel autre type. Son utilisation est également similaire.&lt;/p&gt;

&lt;p&gt;Pour des raisons de commodité, on utilise souvent la boucle &lt;code&gt;foreach&lt;/code&gt; pour itérer sur les éléments d&amp;rsquo;uns liste d&amp;rsquo;objets. L&amp;rsquo;exemple ci-dessous illustre l&amp;rsquo;utilisation d&amp;rsquo;une collection de comptes bancaires.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CompteBancaire comptePierre = new CompteBancaire(&amp;quot;Pierre&amp;quot;, 300, &amp;quot;euros&amp;quot;);
CompteBancaire comptePaul = new CompteBancaire(&amp;quot;Paul&amp;quot;, 200, &amp;quot;dollars&amp;quot;);
CompteBancaire compteJacques = new CompteBancaire(&amp;quot;Jacques&amp;quot;, 50, &amp;quot;euros&amp;quot;);

List&amp;lt;CompteBancaire&amp;gt; listeComptes = new List&amp;lt;CompteBancaire&amp;gt;();
listeComptes.Add(comptePierre);
listeComptes.Add(comptePaul);
listeComptes.Add(compteJacques);

foreach (CompteBancaire compte in listeComptes)
{
    Console.WriteLine(compte.Decrire());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/content/liste_comptes.jpg&#34; class=&#34;content centered bordered&#34; alt=&#34;liste_comptes.jpg&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-success&#34;&gt;
    &lt;strong&gt;Conseil&lt;/strong&gt;
    &lt;p&gt;&lt;p&gt;Ici aussi, la distinction singulier/pluriel est importante : &lt;code&gt;compte&lt;/code&gt; désigne l&amp;rsquo;élément courant de la liste &lt;code&gt;listeComptes&lt;/code&gt;.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>